"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs";
exports.ids = ["vendor-chunks/peerjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs/dist/bundler.mjs":
/*!**********************************************!*\
  !*** ./node_modules/peerjs/dist/bundler.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$7974935686149686),\n/* harmony export */   BufferedConnection: () => (/* binding */ $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b),\n/* harmony export */   ConnectionType: () => (/* binding */ $78455e22dea96b8c$export$3157d57b4135e3bc),\n/* harmony export */   DataConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$49ae800c114df41d),\n/* harmony export */   MsgPack: () => (/* binding */ $6e39230ab36396ad$export$80f5de1a66c4d624),\n/* harmony export */   MsgPackPeer: () => (/* binding */ $1e0aff16be2c328e$export$d72c7bf8eef50853),\n/* harmony export */   Peer: () => (/* binding */ $416260bce337df90$export$ecd1fc136c422448),\n/* harmony export */   PeerError: () => (/* binding */ $23779d1881157a18$export$98871882f492de82),\n/* harmony export */   PeerErrorType: () => (/* binding */ $78455e22dea96b8c$export$9547aaa2e39030ff),\n/* harmony export */   SerializationType: () => (/* binding */ $78455e22dea96b8c$export$89f507cf986a947),\n/* harmony export */   ServerMessageType: () => (/* binding */ $78455e22dea96b8c$export$adb4a1754da6f10d),\n/* harmony export */   SocketEventType: () => (/* binding */ $78455e22dea96b8c$export$3b5c4a4b6354f023),\n/* harmony export */   StreamConnection: () => (/* binding */ $20dbe68149d7aad9$export$72aa44612e2200cd),\n/* harmony export */   \"default\": () => (/* binding */ $dd0187d7f28e386f$export$2e2bcd8739ae039),\n/* harmony export */   util: () => (/* binding */ $4f4134156c446392$export$7debb50ef11d5e0b)\n/* harmony export */ });\n/* harmony import */ var peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! peerjs-js-binarypack */ \"(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\");\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n\n\n\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nclass $fcbcc7538a6776d5$export$f1c5f4c9cb95390b {\n    constructor(){\n        this.chunkedMTU = 16300 // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n        ;\n        // Binary stuff\n        this._dataCount = 1;\n        this.chunk = (blob)=>{\n            const chunks = [];\n            const size = blob.byteLength;\n            const total = Math.ceil(size / this.chunkedMTU);\n            let index = 0;\n            let start = 0;\n            while(start < size){\n                const end = Math.min(size, start + this.chunkedMTU);\n                const b = blob.slice(start, end);\n                const chunk = {\n                    __peerData: this._dataCount,\n                    n: index,\n                    data: b,\n                    total: total\n                };\n                chunks.push(chunk);\n                start = end;\n                index++;\n            }\n            this._dataCount++;\n            return chunks;\n        };\n    }\n}\nfunction $fcbcc7538a6776d5$export$52c89ebcdc4f53f2(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        result.set(buf, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\n\n\nconst $fb63e766cfafaab9$var$webRTCAdapter = //@ts-ignore\n(0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).default || (0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nconst $fb63e766cfafaab9$export$25be9502477c137d = new class {\n    isWebRTCSupported() {\n        return typeof RTCPeerConnection !== \"undefined\";\n    }\n    isBrowserSupported() {\n        const browser = this.getBrowser();\n        const version = this.getVersion();\n        const validBrowser = this.supportedBrowsers.includes(browser);\n        if (!validBrowser) return false;\n        if (browser === \"chrome\") return version >= this.minChromeVersion;\n        if (browser === \"firefox\") return version >= this.minFirefoxVersion;\n        if (browser === \"safari\") return !this.isIOS && version >= this.minSafariVersion;\n        return false;\n    }\n    getBrowser() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.browser;\n    }\n    getVersion() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n    }\n    isUnifiedPlanSupported() {\n        const browser = this.getBrowser();\n        const version = $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n        if (browser === \"chrome\" && version < this.minChromeVersion) return false;\n        if (browser === \"firefox\" && version >= this.minFirefoxVersion) return true;\n        if (!window.RTCRtpTransceiver || !(\"currentDirection\" in RTCRtpTransceiver.prototype)) return false;\n        let tempPc;\n        let supported = false;\n        try {\n            tempPc = new RTCPeerConnection();\n            tempPc.addTransceiver(\"audio\");\n            supported = true;\n        } catch (e) {} finally{\n            if (tempPc) tempPc.close();\n        }\n        return supported;\n    }\n    toString() {\n        return `Supports:\n    browser:${this.getBrowser()}\n    version:${this.getVersion()}\n    isIOS:${this.isIOS}\n    isWebRTCSupported:${this.isWebRTCSupported()}\n    isBrowserSupported:${this.isBrowserSupported()}\n    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;\n    }\n    constructor(){\n        this.isIOS = typeof navigator !== \"undefined\" ? [\n            \"iPad\",\n            \"iPhone\",\n            \"iPod\"\n        ].includes(navigator.platform) : false;\n        this.supportedBrowsers = [\n            \"firefox\",\n            \"chrome\",\n            \"safari\"\n        ];\n        this.minFirefoxVersion = 59;\n        this.minChromeVersion = 72;\n        this.minSafariVersion = 605;\n    }\n}();\n\n\nconst $9a84a32bf0bf36bb$export$f35f128fd59ea256 = (id)=>{\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);\n};\n\n\nconst $0e5fd1585784c252$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);\n\n\nconst $4f4134156c446392$var$DEFAULT_CONFIG = {\n    iceServers: [\n        {\n            urls: \"stun:stun.l.google.com:19302\"\n        },\n        {\n            urls: [\n                \"turn:eu-0.turn.peerjs.com:3478\",\n                \"turn:us-0.turn.peerjs.com:3478\"\n            ],\n            username: \"peerjs\",\n            credential: \"peerjsp\"\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\nclass $4f4134156c446392$export$f8f26dd395d7e1bd extends (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b) {\n    noop() {}\n    blobToArrayBuffer(blob, cb) {\n        const fr = new FileReader();\n        fr.onload = function(evt) {\n            if (evt.target) cb(evt.target.result);\n        };\n        fr.readAsArrayBuffer(blob);\n        return fr;\n    }\n    binaryStringToArrayBuffer(binary) {\n        const byteArray = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++)byteArray[i] = binary.charCodeAt(i) & 0xff;\n        return byteArray.buffer;\n    }\n    isSecure() {\n        return location.protocol === \"https:\";\n    }\n    constructor(...args){\n        super(...args), this.CLOUD_HOST = \"0.peerjs.com\", this.CLOUD_PORT = 443, // Browsers that need chunking:\n        this.chunkedBrowsers = {\n            Chrome: 1,\n            chrome: 1\n        }, // Returns browser-agnostic default config\n        this.defaultConfig = $4f4134156c446392$var$DEFAULT_CONFIG, this.browser = (0, $fb63e766cfafaab9$export$25be9502477c137d).getBrowser(), this.browserVersion = (0, $fb63e766cfafaab9$export$25be9502477c137d).getVersion(), this.pack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack, this.unpack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack, /**\n\t * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.\n\t *\n\t * :::caution\n\t * Only the properties documented here are guaranteed to be present on `util.supports`\n\t * :::\n\t */ this.supports = function() {\n            const supported = {\n                browser: (0, $fb63e766cfafaab9$export$25be9502477c137d).isBrowserSupported(),\n                webRTC: (0, $fb63e766cfafaab9$export$25be9502477c137d).isWebRTCSupported(),\n                audioVideo: false,\n                data: false,\n                binaryBlob: false,\n                reliable: false\n            };\n            if (!supported.webRTC) return supported;\n            let pc;\n            try {\n                pc = new RTCPeerConnection($4f4134156c446392$var$DEFAULT_CONFIG);\n                supported.audioVideo = true;\n                let dc;\n                try {\n                    dc = pc.createDataChannel(\"_PEERJSTEST\", {\n                        ordered: true\n                    });\n                    supported.data = true;\n                    supported.reliable = !!dc.ordered;\n                    // Binary test\n                    try {\n                        dc.binaryType = \"blob\";\n                        supported.binaryBlob = !(0, $fb63e766cfafaab9$export$25be9502477c137d).isIOS;\n                    } catch (e) {}\n                } catch (e) {} finally{\n                    if (dc) dc.close();\n                }\n            } catch (e) {} finally{\n                if (pc) pc.close();\n            }\n            return supported;\n        }(), // Ensure alphanumeric ids\n        this.validateId = (0, $9a84a32bf0bf36bb$export$f35f128fd59ea256), this.randomToken = (0, $0e5fd1585784c252$export$4e61f672936bec77);\n    }\n}\nconst $4f4134156c446392$export$7debb50ef11d5e0b = new $4f4134156c446392$export$f8f26dd395d7e1bd();\n\n\n\nconst $257947e92926277a$var$LOG_PREFIX = \"PeerJS: \";\nvar $257947e92926277a$export$243e62d78d3b544d = /*#__PURE__*/ function(LogLevel) {\n    /**\n\t * Prints no logs.\n\t */ LogLevel[LogLevel[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n\t * Prints only errors.\n\t */ LogLevel[LogLevel[\"Errors\"] = 1] = \"Errors\";\n    /**\n\t * Prints errors and warnings.\n\t */ LogLevel[LogLevel[\"Warnings\"] = 2] = \"Warnings\";\n    /**\n\t * Prints all logs.\n\t */ LogLevel[LogLevel[\"All\"] = 3] = \"All\";\n    return LogLevel;\n}({});\nclass $257947e92926277a$var$Logger {\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(logLevel) {\n        this._logLevel = logLevel;\n    }\n    log(...args) {\n        if (this._logLevel >= 3) this._print(3, ...args);\n    }\n    warn(...args) {\n        if (this._logLevel >= 2) this._print(2, ...args);\n    }\n    error(...args) {\n        if (this._logLevel >= 1) this._print(1, ...args);\n    }\n    setLogFunction(fn) {\n        this._print = fn;\n    }\n    _print(logLevel, ...rest) {\n        const copy = [\n            $257947e92926277a$var$LOG_PREFIX,\n            ...rest\n        ];\n        for(const i in copy)if (copy[i] instanceof Error) copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n        if (logLevel >= 3) console.log(...copy);\n        else if (logLevel >= 2) console.warn(\"WARNING\", ...copy);\n        else if (logLevel >= 1) console.error(\"ERROR\", ...copy);\n    }\n    constructor(){\n        this._logLevel = 0;\n    }\n}\nvar $257947e92926277a$export$2e2bcd8739ae039 = new $257947e92926277a$var$Logger();\n\n\nvar $c4dcfd1d1ea86647$exports = {};\n'use strict';\nvar $c4dcfd1d1ea86647$var$has = Object.prototype.hasOwnProperty, $c4dcfd1d1ea86647$var$prefix = '~';\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $c4dcfd1d1ea86647$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $c4dcfd1d1ea86647$var$Events().__proto__) $c4dcfd1d1ea86647$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $c4dcfd1d1ea86647$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== 'function') throw new TypeError('The listener must be a function');\n    var listener = new $c4dcfd1d1ea86647$var$EE(fn, context || emitter, once), evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $c4dcfd1d1ea86647$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $c4dcfd1d1ea86647$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $c4dcfd1d1ea86647$var$EventEmitter() {\n    this._events = new $c4dcfd1d1ea86647$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($c4dcfd1d1ea86647$var$has.call(events, name)) names.push($c4dcfd1d1ea86647$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n        if (this._events[evt]) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        this._events = new $c4dcfd1d1ea86647$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.off = $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener;\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.addListener = $c4dcfd1d1ea86647$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prefixed = $c4dcfd1d1ea86647$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.EventEmitter = $c4dcfd1d1ea86647$var$EventEmitter;\n$c4dcfd1d1ea86647$exports = $c4dcfd1d1ea86647$var$EventEmitter;\n\n\n\nvar $78455e22dea96b8c$exports = {};\n\n$parcel$export($78455e22dea96b8c$exports, \"ConnectionType\", () => $78455e22dea96b8c$export$3157d57b4135e3bc);\n$parcel$export($78455e22dea96b8c$exports, \"PeerErrorType\", () => $78455e22dea96b8c$export$9547aaa2e39030ff);\n$parcel$export($78455e22dea96b8c$exports, \"BaseConnectionErrorType\", () => $78455e22dea96b8c$export$7974935686149686);\n$parcel$export($78455e22dea96b8c$exports, \"DataConnectionErrorType\", () => $78455e22dea96b8c$export$49ae800c114df41d);\n$parcel$export($78455e22dea96b8c$exports, \"SerializationType\", () => $78455e22dea96b8c$export$89f507cf986a947);\n$parcel$export($78455e22dea96b8c$exports, \"SocketEventType\", () => $78455e22dea96b8c$export$3b5c4a4b6354f023);\n$parcel$export($78455e22dea96b8c$exports, \"ServerMessageType\", () => $78455e22dea96b8c$export$adb4a1754da6f10d);\nvar $78455e22dea96b8c$export$3157d57b4135e3bc = /*#__PURE__*/ function(ConnectionType) {\n    ConnectionType[\"Data\"] = \"data\";\n    ConnectionType[\"Media\"] = \"media\";\n    return ConnectionType;\n}({});\nvar $78455e22dea96b8c$export$9547aaa2e39030ff = /*#__PURE__*/ function(PeerErrorType) {\n    /**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */ PeerErrorType[\"BrowserIncompatible\"] = \"browser-incompatible\";\n    /**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */ PeerErrorType[\"Disconnected\"] = \"disconnected\";\n    /**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */ PeerErrorType[\"InvalidID\"] = \"invalid-id\";\n    /**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */ PeerErrorType[\"InvalidKey\"] = \"invalid-key\";\n    /**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */ PeerErrorType[\"Network\"] = \"network\";\n    /**\n\t * The peer you're trying to connect to does not exist.\n\t */ PeerErrorType[\"PeerUnavailable\"] = \"peer-unavailable\";\n    /**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */ PeerErrorType[\"SslUnavailable\"] = \"ssl-unavailable\";\n    /**\n\t * Unable to reach the server.\n\t */ PeerErrorType[\"ServerError\"] = \"server-error\";\n    /**\n\t * An error from the underlying socket.\n\t */ PeerErrorType[\"SocketError\"] = \"socket-error\";\n    /**\n\t * The underlying socket closed unexpectedly.\n\t */ PeerErrorType[\"SocketClosed\"] = \"socket-closed\";\n    /**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */ PeerErrorType[\"UnavailableID\"] = \"unavailable-id\";\n    /**\n\t * Native WebRTC errors.\n\t */ PeerErrorType[\"WebRTC\"] = \"webrtc\";\n    return PeerErrorType;\n}({});\nvar $78455e22dea96b8c$export$7974935686149686 = /*#__PURE__*/ function(BaseConnectionErrorType) {\n    BaseConnectionErrorType[\"NegotiationFailed\"] = \"negotiation-failed\";\n    BaseConnectionErrorType[\"ConnectionClosed\"] = \"connection-closed\";\n    return BaseConnectionErrorType;\n}({});\nvar $78455e22dea96b8c$export$49ae800c114df41d = /*#__PURE__*/ function(DataConnectionErrorType) {\n    DataConnectionErrorType[\"NotOpenYet\"] = \"not-open-yet\";\n    DataConnectionErrorType[\"MessageToBig\"] = \"message-too-big\";\n    return DataConnectionErrorType;\n}({});\nvar $78455e22dea96b8c$export$89f507cf986a947 = /*#__PURE__*/ function(SerializationType) {\n    SerializationType[\"Binary\"] = \"binary\";\n    SerializationType[\"BinaryUTF8\"] = \"binary-utf8\";\n    SerializationType[\"JSON\"] = \"json\";\n    SerializationType[\"None\"] = \"raw\";\n    return SerializationType;\n}({});\nvar $78455e22dea96b8c$export$3b5c4a4b6354f023 = /*#__PURE__*/ function(SocketEventType) {\n    SocketEventType[\"Message\"] = \"message\";\n    SocketEventType[\"Disconnected\"] = \"disconnected\";\n    SocketEventType[\"Error\"] = \"error\";\n    SocketEventType[\"Close\"] = \"close\";\n    return SocketEventType;\n}({});\nvar $78455e22dea96b8c$export$adb4a1754da6f10d = /*#__PURE__*/ function(ServerMessageType) {\n    ServerMessageType[\"Heartbeat\"] = \"HEARTBEAT\";\n    ServerMessageType[\"Candidate\"] = \"CANDIDATE\";\n    ServerMessageType[\"Offer\"] = \"OFFER\";\n    ServerMessageType[\"Answer\"] = \"ANSWER\";\n    ServerMessageType[\"Open\"] = \"OPEN\";\n    ServerMessageType[\"Error\"] = \"ERROR\";\n    ServerMessageType[\"IdTaken\"] = \"ID-TAKEN\";\n    ServerMessageType[\"InvalidKey\"] = \"INVALID-KEY\";\n    ServerMessageType[\"Leave\"] = \"LEAVE\";\n    ServerMessageType[\"Expire\"] = \"EXPIRE\";\n    return ServerMessageType;\n}({});\n\n\nconst $520832d44ba058c8$export$83d89fbfd8236492 = \"1.5.5\";\n\n\nclass $8f5bfa60836d261d$export$4798917dbf149b79 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    constructor(secure, host, port, path, key, pingInterval = 5000){\n        super(), this.pingInterval = pingInterval, this._disconnected = true, this._messagesQueue = [];\n        const wsProtocol = secure ? \"wss://\" : \"ws://\";\n        this._baseUrl = wsProtocol + host + \":\" + port + path + \"peerjs?key=\" + key;\n    }\n    start(id, token) {\n        this._id = id;\n        const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;\n        if (!!this._socket || !this._disconnected) return;\n        this._socket = new WebSocket(wsUrl + \"&version=\" + (0, $520832d44ba058c8$export$83d89fbfd8236492));\n        this._disconnected = false;\n        this._socket.onmessage = (event)=>{\n            let data;\n            try {\n                data = JSON.parse(event.data);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Server message received:\", data);\n            } catch (e) {\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Invalid server message\", event.data);\n                return;\n            }\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, data);\n        };\n        this._socket.onclose = (event)=>{\n            if (this._disconnected) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket closed.\", event);\n            this._cleanup();\n            this._disconnected = true;\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected);\n        };\n        // Take care of the queue of connections if necessary and make sure Peer knows\n        // socket is open.\n        this._socket.onopen = ()=>{\n            if (this._disconnected) return;\n            this._sendQueuedMessages();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket open\");\n            this._scheduleHeartbeat();\n        };\n    }\n    _scheduleHeartbeat() {\n        this._wsPingTimer = setTimeout(()=>{\n            this._sendHeartbeat();\n        }, this.pingInterval);\n    }\n    _sendHeartbeat() {\n        if (!this._wsOpen()) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Cannot send heartbeat, because socket closed`);\n            return;\n        }\n        const message = JSON.stringify({\n            type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Heartbeat\n        });\n        this._socket.send(message);\n        this._scheduleHeartbeat();\n    }\n    /** Is the websocket currently open? */ _wsOpen() {\n        return !!this._socket && this._socket.readyState === 1;\n    }\n    /** Send queued messages. */ _sendQueuedMessages() {\n        //Create copy of queue and clear it,\n        //because send method push the message back to queue if smth will go wrong\n        const copiedQueue = [\n            ...this._messagesQueue\n        ];\n        this._messagesQueue = [];\n        for (const message of copiedQueue)this.send(message);\n    }\n    /** Exposed send for DC & Peer. */ send(data) {\n        if (this._disconnected) return;\n        // If we didn't get an ID yet, we can't yet send anything so we should queue\n        // up these messages.\n        if (!this._id) {\n            this._messagesQueue.push(data);\n            return;\n        }\n        if (!data.type) {\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, \"Invalid message\");\n            return;\n        }\n        if (!this._wsOpen()) return;\n        const message = JSON.stringify(data);\n        this._socket.send(message);\n    }\n    close() {\n        if (this._disconnected) return;\n        this._cleanup();\n        this._disconnected = true;\n    }\n    _cleanup() {\n        if (this._socket) {\n            this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;\n            this._socket.close();\n            this._socket = undefined;\n        }\n        clearTimeout(this._wsPingTimer);\n    }\n}\n\n\n\n\n\n\nclass $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a {\n    constructor(connection){\n        this.connection = connection;\n    }\n    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {\n        const peerConnection = this._startPeerConnection();\n        // Set the connection's PC.\n        this.connection.peerConnection = peerConnection;\n        if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);\n        // What do we need to do now?\n        if (options.originator) {\n            const dataConnection = this.connection;\n            const config = {\n                ordered: !!options.reliable\n            };\n            const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);\n            dataConnection._initializeDataChannel(dataChannel);\n            this._makeOffer();\n        } else this.handleSDP(\"OFFER\", options.sdp);\n    }\n    /** Start a PC. */ _startPeerConnection() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Creating RTCPeerConnection.\");\n        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n        this._setupListeners(peerConnection);\n        return peerConnection;\n    }\n    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {\n        const peerId = this.connection.peer;\n        const connectionId = this.connection.connectionId;\n        const connectionType = this.connection.type;\n        const provider = this.connection.provider;\n        // ICE CANDIDATES.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for ICE candidates.\");\n        peerConnection.onicecandidate = (evt)=>{\n            if (!evt.candidate || !evt.candidate.candidate) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n            provider.socket.send({\n                type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate,\n                payload: {\n                    candidate: evt.candidate,\n                    type: connectionType,\n                    connectionId: connectionId\n                },\n                dst: peerId\n            });\n        };\n        peerConnection.oniceconnectionstatechange = ()=>{\n            switch(peerConnection.iceConnectionState){\n                case \"failed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is failed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).NegotiationFailed, \"Negotiation of connection to \" + peerId + \" failed.\");\n                    this.connection.close();\n                    break;\n                case \"closed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is closed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).ConnectionClosed, \"Connection to \" + peerId + \" closed.\");\n                    this.connection.close();\n                    break;\n                case \"disconnected\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState changed to disconnected on the connection with \" + peerId);\n                    break;\n                case \"completed\":\n                    peerConnection.onicecandidate = ()=>{};\n                    break;\n            }\n            this.connection.emit(\"iceStateChanged\", peerConnection.iceConnectionState);\n        };\n        // DATACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for data channel\");\n        // Fired between offer and answer, so options should already be saved\n        // in the options hash.\n        peerConnection.ondatachannel = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received data channel\");\n            const dataChannel = evt.channel;\n            const connection = provider.getConnection(peerId, connectionId);\n            connection._initializeDataChannel(dataChannel);\n        };\n        // MEDIACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for remote stream\");\n        peerConnection.ontrack = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received remote stream\");\n            const stream = evt.streams[0];\n            const connection = provider.getConnection(peerId, connectionId);\n            if (connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                const mediaConnection = connection;\n                this._addStreamToMediaConnection(stream, mediaConnection);\n            }\n        };\n    }\n    cleanup() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n        const peerConnection = this.connection.peerConnection;\n        if (!peerConnection) return;\n        this.connection.peerConnection = null;\n        //unsubscribe from all PeerConnection's events\n        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};\n        const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n        let dataChannelNotClosed = false;\n        const dataChannel = this.connection.dataChannel;\n        if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();\n    }\n    async _makeOffer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const offer = await peerConnection.createOffer(this.connection.options.constraints);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created offer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n            try {\n                await peerConnection.setLocalDescription(offer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n                let payload = {\n                    sdp: offer,\n                    type: this.connection.type,\n                    connectionId: this.connection.connectionId,\n                    metadata: this.connection.metadata\n                };\n                if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                    const dataConnection = this.connection;\n                    payload = {\n                        ...payload,\n                        label: dataConnection.label,\n                        reliable: dataConnection.reliable,\n                        serialization: dataConnection.serialization\n                    };\n                }\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer,\n                    payload: payload,\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                // TODO: investigate why _makeOffer is being called from the answer\n                if (err != \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                    provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n                }\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to createOffer, \", err_1);\n        }\n    }\n    async _makeAnswer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const answer = await peerConnection.createAnswer();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created answer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n            try {\n                await peerConnection.setLocalDescription(answer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer,\n                    payload: {\n                        sdp: answer,\n                        type: this.connection.type,\n                        connectionId: this.connection.connectionId\n                    },\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to create answer, \", err_1);\n        }\n    }\n    /** Handle an SDP. */ async handleSDP(type, sdp) {\n        sdp = new RTCSessionDescription(sdp);\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Setting remote description\", sdp);\n        const self = this;\n        try {\n            await peerConnection.setRemoteDescription(sdp);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n            if (type === \"OFFER\") await self._makeAnswer();\n        } catch (err) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setRemoteDescription, \", err);\n        }\n    }\n    /** Handle a candidate. */ async handleCandidate(ice) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`handleCandidate:`, ice);\n        try {\n            await this.connection.peerConnection.addIceCandidate(ice);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);\n        } catch (err) {\n            this.connection.provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to handleCandidate, \", err);\n        }\n    }\n    _addTracksToConnection(stream, peerConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add tracks from stream ${stream.id} to peer connection`);\n        if (!peerConnection.addTrack) return (0, $257947e92926277a$export$2e2bcd8739ae039).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);\n        stream.getTracks().forEach((track)=>{\n            peerConnection.addTrack(track, stream);\n        });\n    }\n    _addStreamToMediaConnection(stream, mediaConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);\n        mediaConnection.addStream(stream);\n    }\n}\n\n\n\n\n\nclass $23779d1881157a18$export$6a678e589c8a4542 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    /**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */ emitError(type, err) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error:\", err);\n        // @ts-ignore\n        this.emit(\"error\", new $23779d1881157a18$export$98871882f492de82(`${type}`, err));\n    }\n}\nclass $23779d1881157a18$export$98871882f492de82 extends Error {\n    /**\n\t * @internal\n\t */ constructor(type, err){\n        if (typeof err === \"string\") super(err);\n        else {\n            super();\n            Object.assign(this, err);\n        }\n        this.type = type;\n    }\n}\n\n\nclass $5045192fc6d387ba$export$23a2a68283c24d80 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    /**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */ get open() {\n        return this._open;\n    }\n    constructor(/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */ peer, provider, options){\n        super(), this.peer = peer, this.provider = provider, this.options = options, this._open = false;\n        this.metadata = options.metadata;\n    }\n}\n\n\nclass $5c1d08c7c57da9a3$export$4a84e95a2324ac29 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"mc_\";\n    /**\n\t * For media connections, this is always 'media'.\n\t */ get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media;\n    }\n    get localStream() {\n        return this._localStream;\n    }\n    get remoteStream() {\n        return this._remoteStream;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this._localStream = this.options._stream;\n        this.connectionId = this.options.connectionId || $5c1d08c7c57da9a3$export$4a84e95a2324ac29.ID_PREFIX + (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken();\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        if (this._localStream) this._negotiator.startConnection({\n            _stream: this._localStream,\n            originator: true\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this.emit(\"willCloseOnRemote\");\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    addStream(remoteStream) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Receiving stream\", remoteStream);\n        this._remoteStream = remoteStream;\n        super.emit(\"stream\", remoteStream); // Should we call this `open`?\n    }\n    /**\n\t * @internal\n\t */ handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                // Forward to negotiator\n                this._negotiator.handleSDP(type, payload.sdp);\n                this._open = true;\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Unrecognized message type:${type} from peer:${this.peer}`);\n                break;\n        }\n    }\n    /**\n     * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call\n     * `answer` on the media connection provided by the callback to accept the call\n     * and optionally send your own media stream.\n\n     *\n     * @param stream A WebRTC media stream.\n     * @param options\n     * @returns\n     */ answer(stream, options = {}) {\n        if (this._localStream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");\n            return;\n        }\n        this._localStream = stream;\n        if (options && options.sdpTransform) this.options.sdpTransform = options.sdpTransform;\n        this._negotiator.startConnection({\n            ...this.options._payload,\n            _stream: stream\n        });\n        // Retrieve lost messages stored because PeerConnection not set up.\n        const messages = this.provider._getMessages(this.connectionId);\n        for (const message of messages)this.handleMessage(message);\n        this._open = true;\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /**\n\t * Closes the media connection.\n\t */ close() {\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        this._localStream = null;\n        this._remoteStream = null;\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.options && this.options._stream) this.options._stream = null;\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n}\n\n\n\n\n\n\nclass $abf266641927cd89$export$2c4e825dc9120f87 {\n    constructor(_options){\n        this._options = _options;\n    }\n    _buildRequest(method) {\n        const protocol = this._options.secure ? \"https\" : \"http\";\n        const { host: host, port: port, path: path, key: key } = this._options;\n        const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);\n        // TODO: Why timestamp, why random?\n        url.searchParams.set(\"ts\", `${Date.now()}${Math.random()}`);\n        url.searchParams.set(\"version\", (0, $520832d44ba058c8$export$83d89fbfd8236492));\n        return fetch(url.href, {\n            referrerPolicy: this._options.referrerPolicy\n        });\n    }\n    /** Get a unique ID from the server via XHR and initialize with it. */ async retrieveId() {\n        try {\n            const response = await this._buildRequest(\"id\");\n            if (response.status !== 200) throw new Error(`Error. Status:${response.status}`);\n            return response.text();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving ID\", error);\n            let pathError = \"\";\n            if (this._options.path === \"/\" && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) pathError = \" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\";\n            throw new Error(\"Could not get an ID from the server.\" + pathError);\n        }\n    }\n    /** @deprecated */ async listAllPeers() {\n        try {\n            const response = await this._buildRequest(\"peers\");\n            if (response.status !== 200) {\n                if (response.status === 401) {\n                    let helpfulError = \"\";\n                    if (this._options.host === (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) helpfulError = \"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\";\n                    else helpfulError = \"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\";\n                    throw new Error(\"It doesn't look like you have permission to list peers IDs. \" + helpfulError);\n                }\n                throw new Error(`Error. Status:${response.status}`);\n            }\n            return response.json();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving list peers\", error);\n            throw new Error(\"Could not get list peers from the server.\" + error);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nclass $6366c4ca161bc297$export$d365f7ad9d7df9c9 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"dc_\";\n    static #_2 = this.MAX_BUFFERED_AMOUNT = 8388608;\n    get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.connectionId = this.options.connectionId || $6366c4ca161bc297$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $0e5fd1585784c252$export$4e61f672936bec77)();\n        this.label = this.options.label || this.connectionId;\n        this.reliable = !!this.options.reliable;\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        this._negotiator.startConnection(this.options._payload || {\n            originator: true,\n            reliable: this.reliable\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this._open = true;\n            this.emit(\"open\");\n        };\n        this.dataChannel.onmessage = (e)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc onmessage:`, e.data);\n        // this._handleDataMessage(e);\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /** Allows user to close connection. */ close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.dataChannel) {\n            this.dataChannel.onopen = null;\n            this.dataChannel.onmessage = null;\n            this.dataChannel.onclose = null;\n            this.dataChannel = null;\n        }\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n    /** Allows user to send data. */ send(data, chunked = false) {\n        if (!this.open) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).NotOpenYet, \"Connection is not open. You should listen for the `open` event before sending messages.\");\n            return;\n        }\n        return this._send(data, chunked);\n    }\n    async handleMessage(message) {\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                await this._negotiator.handleSDP(message.type, payload.sdp);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                await this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n                break;\n        }\n    }\n}\n\n\nclass $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    get bufferSize() {\n        return this._bufferSize;\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.addEventListener(\"message\", (e)=>this._handleDataMessage(e));\n    }\n    _bufferedSend(msg) {\n        if (this._buffering || !this._trySend(msg)) {\n            this._buffer.push(msg);\n            this._bufferSize = this._buffer.length;\n        }\n    }\n    // Returns true if the send succeeds.\n    _trySend(msg) {\n        if (!this.open) return false;\n        if (this.dataChannel.bufferedAmount > (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT) {\n            this._buffering = true;\n            setTimeout(()=>{\n                this._buffering = false;\n                this._tryBuffer();\n            }, 50);\n            return false;\n        }\n        try {\n            this.dataChannel.send(msg);\n        } catch (e) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n            this._buffering = true;\n            this.close();\n            return false;\n        }\n        return true;\n    }\n    // Try to send the first message in the buffer.\n    _tryBuffer() {\n        if (!this.open) return;\n        if (this._buffer.length === 0) return;\n        const msg = this._buffer[0];\n        if (this._trySend(msg)) {\n            this._buffer.shift();\n            this._bufferSize = this._buffer.length;\n            this._tryBuffer();\n        }\n    }\n    close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        this._buffer = [];\n        this._bufferSize = 0;\n        super.close();\n    }\n    constructor(...args){\n        super(...args), this._buffer = [], this._bufferSize = 0, this._buffering = false;\n    }\n}\n\n\n\n\nclass $9fcfddb3ae148f88$export$f0a5a64d5bb37108 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    close(options) {\n        super.close(options);\n        this._chunkedData = {};\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options), this.chunker = new (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b)(), this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).Binary, this._chunkedData = {};\n    }\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack)(data);\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData) {\n            if (peerData.type === \"close\") {\n                this.close();\n                return;\n            }\n            // Chunked data -- piece things back together.\n            // @ts-ignore\n            this._handleChunk(deserializedData);\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _handleChunk(data) {\n        const id = data.__peerData;\n        const chunkInfo = this._chunkedData[id] || {\n            data: [],\n            count: 0,\n            total: data.total\n        };\n        chunkInfo.data[data.n] = new Uint8Array(data.data);\n        chunkInfo.count++;\n        this._chunkedData[id] = chunkInfo;\n        if (chunkInfo.total === chunkInfo.count) {\n            // Clean up before making the recursive call to `_handleDataMessage`.\n            delete this._chunkedData[id];\n            // We've received all the chunks--time to construct the complete data.\n            // const data = new Blob(chunkInfo.data);\n            const data = (0, $fcbcc7538a6776d5$export$52c89ebcdc4f53f2)(chunkInfo.data);\n            this._handleDataMessage({\n                data: data\n            });\n        }\n    }\n    _send(data, chunked) {\n        const blob = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack)(data);\n        if (blob instanceof Promise) return this._send_blob(blob);\n        if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    async _send_blob(blobPromise) {\n        const blob = await blobPromise;\n        if (blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    _sendChunks(blob) {\n        const blobs = this.chunker.chunk(blob);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);\n        for (const blob of blobs)this.send(blob, true);\n    }\n}\n\n\n\n\nclass $bbaee3f15f714663$export$6f88fe47d32c9c94 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    _handleDataMessage({ data: data }) {\n        super.emit(\"data\", data);\n    }\n    _send(data, _chunked) {\n        this._bufferedSend(data);\n    }\n    constructor(...args){\n        super(...args), this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).None;\n    }\n}\n\n\n\n\n\nclass $817f931e3f9096cf$export$48880ac635f47186 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = this.parse(this.decoder.decode(data));\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData && peerData.type === \"close\") {\n            this.close();\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _send(data, _chunked) {\n        const encodedData = this.encoder.encode(this.stringify(data));\n        if (encodedData.byteLength >= (0, $4f4134156c446392$export$7debb50ef11d5e0b).chunkedMTU) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).MessageToBig, \"Message too big for JSON channel\");\n            return;\n        }\n        this._bufferedSend(encodedData);\n    }\n    constructor(...args){\n        super(...args), this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).JSON, this.encoder = new TextEncoder(), this.decoder = new TextDecoder(), this.stringify = JSON.stringify, this.parse = JSON.parse;\n    }\n}\n\n\n\nclass $416260bce337df90$var$PeerOptions {\n}\nclass $416260bce337df90$export$ecd1fc136c422448 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    static #_ = this.DEFAULT_KEY = \"peerjs\";\n    /**\n\t * The brokering ID of this peer\n\t *\n\t * If no ID was specified in {@apilink Peer | the constructor},\n\t * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.\n\t */ get id() {\n        return this._id;\n    }\n    get options() {\n        return this._options;\n    }\n    get open() {\n        return this._open;\n    }\n    /**\n\t * @internal\n\t */ get socket() {\n        return this._socket;\n    }\n    /**\n\t * A hash of all connections associated with this peer, keyed by the remote peer's ID.\n\t * @deprecated\n\t * Return type will change from Object to Map<string,[]>\n\t */ get connections() {\n        const plainConnections = Object.create(null);\n        for (const [k, v] of this._connections)plainConnections[k] = v;\n        return plainConnections;\n    }\n    /**\n\t * true if this peer and all of its connections can no longer be used.\n\t */ get destroyed() {\n        return this._destroyed;\n    }\n    /**\n\t * false if there is an active connection to the PeerServer.\n\t */ get disconnected() {\n        return this._disconnected;\n    }\n    constructor(id, options){\n        super(), this._serializers = {\n            raw: (0, $bbaee3f15f714663$export$6f88fe47d32c9c94),\n            json: (0, $817f931e3f9096cf$export$48880ac635f47186),\n            binary: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            \"binary-utf8\": (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            default: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108)\n        }, this._id = null, this._lastServerId = null, // States.\n        this._destroyed = false // Connections have been killed\n        , this._disconnected = false // Connection to PeerServer killed but P2P connections still active\n        , this._open = false // Sockets and such are not yet open.\n        , this._connections = new Map() // All connections for this peer.\n        , this._lostMessages = new Map() // src => [list of messages]\n        ;\n        let userId;\n        // Deal with overloading\n        if (id && id.constructor == Object) options = id;\n        else if (id) userId = id.toString();\n        // Configurize options\n        options = {\n            debug: 0,\n            host: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST,\n            port: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_PORT,\n            path: \"/\",\n            key: $416260bce337df90$export$ecd1fc136c422448.DEFAULT_KEY,\n            token: (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken(),\n            config: (0, $4f4134156c446392$export$7debb50ef11d5e0b).defaultConfig,\n            referrerPolicy: \"strict-origin-when-cross-origin\",\n            serializers: {},\n            ...options\n        };\n        this._options = options;\n        this._serializers = {\n            ...this._serializers,\n            ...this.options.serializers\n        };\n        // Detect relative URL host.\n        if (this._options.host === \"/\") this._options.host = window.location.hostname;\n        // Set path correctly.\n        if (this._options.path) {\n            if (this._options.path[0] !== \"/\") this._options.path = \"/\" + this._options.path;\n            if (this._options.path[this._options.path.length - 1] !== \"/\") this._options.path += \"/\";\n        }\n        // Set whether we use SSL to same as current host\n        if (this._options.secure === undefined && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = (0, $4f4134156c446392$export$7debb50ef11d5e0b).isSecure();\n        else if (this._options.host == (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = true;\n        // Set a custom log function if present\n        if (this._options.logFunction) (0, $257947e92926277a$export$2e2bcd8739ae039).setLogFunction(this._options.logFunction);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).logLevel = this._options.debug || 0;\n        this._api = new (0, $abf266641927cd89$export$2c4e825dc9120f87)(options);\n        this._socket = this._createServerConnection();\n        // Sanity checks\n        // Ensure WebRTC supported\n        if (!(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.audioVideo && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.data) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).BrowserIncompatible, \"The current browser does not support WebRTC\");\n            return;\n        }\n        // Ensure alphanumeric id\n        if (!!userId && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).validateId(userId)) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidID, `ID \"${userId}\" is invalid`);\n            return;\n        }\n        if (userId) this._initialize(userId);\n        else this._api.retrieveId().then((id)=>this._initialize(id)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n    _createServerConnection() {\n        const socket = new (0, $8f5bfa60836d261d$export$4798917dbf149b79)(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, (data)=>{\n            this._handleMessage(data);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, (error)=>{\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketError, error);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected, ()=>{\n            if (this.disconnected) return;\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Network, \"Lost connection to server.\");\n            this.disconnect();\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Close, ()=>{\n            if (this.disconnected) return;\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketClosed, \"Underlying socket is already closed.\");\n        });\n        return socket;\n    }\n    /** Initialize a connection with the server. */ _initialize(id) {\n        this._id = id;\n        this.socket.start(id, this._options.token);\n    }\n    /** Handles messages from the server. */ _handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        const peerId = message.src;\n        switch(type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Open:\n                this._lastServerId = this.id;\n                this._open = true;\n                this.emit(\"open\", this.id);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Error:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, payload.msg);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).IdTaken:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).UnavailableID, `ID \"${this.id}\" is taken`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).InvalidKey:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidKey, `API KEY \"${this._options.key}\" is invalid`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Leave:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received leave message from ${peerId}`);\n                this._cleanupPeer(peerId);\n                this._connections.delete(peerId);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Expire:\n                this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).PeerUnavailable, `Could not connect to peer ${peerId}`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer:\n                {\n                    // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n                    const connectionId = payload.connectionId;\n                    let connection = this.getConnection(peerId, connectionId);\n                    if (connection) {\n                        connection.close();\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Offer received for existing Connection ID:${connectionId}`);\n                    }\n                    // Create a new connection.\n                    if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata\n                        });\n                        connection = mediaConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"call\", mediaConnection);\n                    } else if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                        const dataConnection = new this._serializers[payload.serialization](peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata,\n                            label: payload.label,\n                            serialization: payload.serialization,\n                            reliable: payload.reliable\n                        });\n                        connection = dataConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"connection\", dataConnection);\n                    } else {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Received malformed connection type:${payload.type}`);\n                        return;\n                    }\n                    // Find messages.\n                    const messages = this._getMessages(connectionId);\n                    for (const message of messages)connection.handleMessage(message);\n                    break;\n                }\n            default:\n                {\n                    if (!payload) {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`You received a malformed message from ${peerId} of type ${type}`);\n                        return;\n                    }\n                    const connectionId = payload.connectionId;\n                    const connection = this.getConnection(peerId, connectionId);\n                    if (connection && connection.peerConnection) // Pass it on.\n                    connection.handleMessage(message);\n                    else if (connectionId) // Store for possible later use\n                    this._storeMessage(connectionId, message);\n                    else (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You received an unrecognized message:\", message);\n                    break;\n                }\n        }\n    }\n    /** Stores messages without a set up connection, to be claimed later. */ _storeMessage(connectionId, message) {\n        if (!this._lostMessages.has(connectionId)) this._lostMessages.set(connectionId, []);\n        this._lostMessages.get(connectionId).push(message);\n    }\n    /**\n\t * Retrieve messages from lost message store\n\t * @internal\n\t */ //TODO Change it to private\n    _getMessages(connectionId) {\n        const messages = this._lostMessages.get(connectionId);\n        if (messages) {\n            this._lostMessages.delete(connectionId);\n            return messages;\n        }\n        return [];\n    }\n    /**\n\t * Connects to the remote peer specified by id and returns a data connection.\n\t * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).\n\t * @param options for specifying details about Peer Connection\n\t */ connect(peer, options = {}) {\n        options = {\n            serialization: \"default\",\n            ...options\n        };\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        const dataConnection = new this._serializers[options.serialization](peer, this, options);\n        this._addConnection(peer, dataConnection);\n        return dataConnection;\n    }\n    /**\n\t * Calls the remote peer specified by id and returns a media connection.\n\t * @param peer The brokering ID of the remote peer (their peer.id).\n\t * @param stream The caller's media stream\n\t * @param options Metadata associated with the connection, passed in by whoever initiated the connection.\n\t */ call(peer, stream, options = {}) {\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        if (!stream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\");\n            return;\n        }\n        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peer, this, {\n            ...options,\n            _stream: stream\n        });\n        this._addConnection(peer, mediaConnection);\n        return mediaConnection;\n    }\n    /** Add a data/media connection to this peer. */ _addConnection(peerId, connection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);\n        if (!this._connections.has(peerId)) this._connections.set(peerId, []);\n        this._connections.get(peerId).push(connection);\n    }\n    //TODO should be private\n    _removeConnection(connection) {\n        const connections = this._connections.get(connection.peer);\n        if (connections) {\n            const index = connections.indexOf(connection);\n            if (index !== -1) connections.splice(index, 1);\n        }\n        //remove from lost messages\n        this._lostMessages.delete(connection.connectionId);\n    }\n    /** Retrieve a data/media connection for this peer. */ getConnection(peerId, connectionId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return null;\n        for (const connection of connections){\n            if (connection.connectionId === connectionId) return connection;\n        }\n        return null;\n    }\n    _delayedAbort(type, message) {\n        setTimeout(()=>{\n            this._abort(type, message);\n        }, 0);\n    }\n    /**\n\t * Emits an error message and destroys the Peer.\n\t * The Peer is not destroyed if it's in a disconnected state, in which case\n\t * it retains its disconnected state and its existing connections.\n\t */ _abort(type, message) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Aborting!\");\n        this.emitError(type, message);\n        if (!this._lastServerId) this.destroy();\n        else this.disconnect();\n    }\n    /**\n\t * Destroys the Peer: closes all active connections as well as the connection\n\t * to the server.\n\t *\n\t * :::caution\n\t * This cannot be undone; the respective peer object will no longer be able\n\t * to create or receive any connections, its ID will be forfeited on the server,\n\t * and all of its data and media connections will be closed.\n\t * :::\n\t */ destroy() {\n        if (this.destroyed) return;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Destroy peer with ID:${this.id}`);\n        this.disconnect();\n        this._cleanup();\n        this._destroyed = true;\n        this.emit(\"close\");\n    }\n    /** Disconnects every connection on this peer. */ _cleanup() {\n        for (const peerId of this._connections.keys()){\n            this._cleanupPeer(peerId);\n            this._connections.delete(peerId);\n        }\n        this.socket.removeAllListeners();\n    }\n    /** Closes all connections to this peer. */ _cleanupPeer(peerId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return;\n        for (const connection of connections)connection.close();\n    }\n    /**\n\t * Disconnects the Peer's connection to the PeerServer. Does not close any\n\t *  active connections.\n\t * Warning: The peer can no longer create or accept connections after being\n\t *  disconnected. It also cannot reconnect to the server.\n\t */ disconnect() {\n        if (this.disconnected) return;\n        const currentId = this.id;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Disconnect peer with ID:${currentId}`);\n        this._disconnected = true;\n        this._open = false;\n        this.socket.close();\n        this._lastServerId = currentId;\n        this._id = null;\n        this.emit(\"disconnected\", currentId);\n    }\n    /** Attempts to reconnect with the same ID.\n\t *\n\t * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.\n\t * Destroyed peers cannot be reconnected.\n\t * If the connection fails (as an example, if the peer's old ID is now taken),\n\t * the peer's existing connections will not close, but any associated errors events will fire.\n\t */ reconnect() {\n        if (this.disconnected && !this.destroyed) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Attempting reconnection to server with ID ${this._lastServerId}`);\n            this._disconnected = false;\n            this._initialize(this._lastServerId);\n        } else if (this.destroyed) throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n        else if (!this.disconnected && !this.open) // Do nothing. We're still connecting the first time.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"In a hurry? We're still trying to make the initial connection!\");\n        else throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);\n    }\n    /**\n\t * Get a list of available peer IDs. If you're running your own server, you'll\n\t * want to set allow_discovery: true in the PeerServer options. If you're using\n\t * the cloud server, email team@peerjs.com to get the functionality enabled for\n\t * your key.\n\t */ listAllPeers(cb = (_)=>{}) {\n        this._api.listAllPeers().then((peers)=>cb(peers)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n}\n\n\n\n\n\n\nclass $20dbe68149d7aad9$export$72aa44612e2200cd extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        }), this._CHUNK_SIZE = 32768, this._splitStream = new TransformStream({\n            transform: (chunk, controller)=>{\n                for(let split = 0; split < chunk.length; split += this._CHUNK_SIZE)controller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n            }\n        }), this._rawSendStream = new WritableStream({\n            write: async (chunk, controller)=>{\n                const openEvent = new Promise((resolve)=>this.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n                        once: true\n                    }));\n                // if we can send the chunk now, send it\n                // if not, we wait until at least half of the sending buffer is free again\n                await (this.dataChannel.bufferedAmount <= (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n                // TODO: what can go wrong here?\n                try {\n                    this.dataChannel.send(chunk);\n                } catch (e) {\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n                    controller.error(e);\n                    this.close();\n                }\n            }\n        }), this.writer = this._splitStream.writable.getWriter(), this._rawReadStream = new ReadableStream({\n            start: (controller)=>{\n                this.once(\"open\", ()=>{\n                    this.dataChannel.addEventListener(\"message\", (e)=>{\n                        controller.enqueue(e.data);\n                    });\n                });\n            }\n        });\n        this._splitStream.readable.pipeTo(this._rawSendStream);\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.bufferedAmountLowThreshold = (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT / 2;\n    }\n}\n\n\nclass $6e39230ab36396ad$export$80f5de1a66c4d624 extends (0, $20dbe68149d7aad9$export$72aa44612e2200cd) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, options), this.serialization = \"MsgPack\", this._encoder = new (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.Encoder)();\n        (async ()=>{\n            for await (const msg of (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.decodeMultiStream)(this._rawReadStream)){\n                // @ts-ignore\n                if (msg.__peerData?.type === \"close\") {\n                    this.close();\n                    return;\n                }\n                this.emit(\"data\", msg);\n            }\n        })();\n    }\n    _send(data) {\n        return this.writer.write(this._encoder.encode(data));\n    }\n}\n\n\nclass $1e0aff16be2c328e$export$d72c7bf8eef50853 extends (0, $416260bce337df90$export$ecd1fc136c422448) {\n    constructor(...args){\n        super(...args), this._serializers = {\n            MsgPack: $6e39230ab36396ad$export$80f5de1a66c4d624,\n            default: (0, $6e39230ab36396ad$export$80f5de1a66c4d624)\n        };\n    }\n}\n\n\n\n\n\n\n\nvar $dd0187d7f28e386f$export$2e2bcd8739ae039 = (0, $416260bce337df90$export$ecd1fc136c422448);\n\n\n\n//# sourceMappingURL=bundler.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzL2Rpc3QvYnVuZGxlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNoQztBQUN3RDs7O0FBRzFHO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxJQUFJLHNEQUFvQixpQkFBaUIsc0RBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7OztBQUdKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsTUFBTSxHQUFHLFNBQVMsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrR0FBa0cscURBQWM7QUFDaEg7QUFDQSx3Q0FBd0MsK0RBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7OztBQUc2NEI7QUFDNzRCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGlzaG93cmFnZVxcT25lRHJpdmVcXERlc2t0b3BcXGZpbGVzYW1vc2FcXG5vZGVfbW9kdWxlc1xccGVlcmpzXFxkaXN0XFxidW5kbGVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhY2sgYXMgJGdDY2JZJHBhY2ssIHVucGFjayBhcyAkZ0NjYlkkdW5wYWNrfSBmcm9tIFwicGVlcmpzLWpzLWJpbmFyeXBhY2tcIjtcbmltcG9ydCAkZ0NjYlkkd2VicnRjYWRhcHRlciBmcm9tIFwid2VicnRjLWFkYXB0ZXJcIjtcbmltcG9ydCB7RW5jb2RlciBhcyAkZ0NjYlkkRW5jb2RlciwgZGVjb2RlTXVsdGlTdHJlYW0gYXMgJGdDY2JZJGRlY29kZU11bHRpU3RyZWFtfSBmcm9tIFwiQG1zZ3BhY2svbXNncGFja1wiO1xuXG5cbmZ1bmN0aW9uICRwYXJjZWwkZXhwb3J0KGUsIG4sIHYsIHMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIG4sIHtnZXQ6IHYsIHNldDogcywgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG59XG5jbGFzcyAkZmNiY2M3NTM4YTY3NzZkNSRleHBvcnQkZjFjNWY0YzljYjk1MzkwYiB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5jaHVua2VkTVRVID0gMTYzMDAgLy8gVGhlIG9yaWdpbmFsIDYwMDAwIGJ5dGVzIHNldHRpbmcgZG9lcyBub3Qgd29yayB3aGVuIHNlbmRpbmcgZGF0YSBmcm9tIEZpcmVmb3ggdG8gQ2hyb21lLCB3aGljaCBpcyBcImN1dCBvZmZcIiBhZnRlciAxNjM4NCBieXRlcyBhbmQgZGVsaXZlcmVkIGluZGl2aWR1YWxseS5cbiAgICAgICAgO1xuICAgICAgICAvLyBCaW5hcnkgc3R1ZmZcbiAgICAgICAgdGhpcy5fZGF0YUNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5jaHVuayA9IChibG9iKT0+e1xuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgICAgICBjb25zdCBzaXplID0gYmxvYi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBNYXRoLmNlaWwoc2l6ZSAvIHRoaXMuY2h1bmtlZE1UVSk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlKHN0YXJ0IDwgc2l6ZSl7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc2l6ZSwgc3RhcnQgKyB0aGlzLmNodW5rZWRNVFUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBibG9iLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0ge1xuICAgICAgICAgICAgICAgICAgICBfX3BlZXJEYXRhOiB0aGlzLl9kYXRhQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIG46IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBiLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGF0YUNvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uICRmY2JjYzc1MzhhNjc3NmQ1JGV4cG9ydCQ1MmM4OWViY2RjNGY1M2YyKGJ1ZnMpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgZm9yIChjb25zdCBidWYgb2YgYnVmcylzaXplICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMpe1xuICAgICAgICByZXN1bHQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cblxuXG5jb25zdCAkZmI2M2U3NjZjZmFmYWFiOSR2YXIkd2ViUlRDQWRhcHRlciA9IC8vQHRzLWlnbm9yZVxuKDAsICRnQ2NiWSR3ZWJydGNhZGFwdGVyKS5kZWZhdWx0IHx8ICgwLCAkZ0NjYlkkd2VicnRjYWRhcHRlcik7XG5jb25zdCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCA9IG5ldyBjbGFzcyB7XG4gICAgaXNXZWJSVENTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5nZXRWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IHZhbGlkQnJvd3NlciA9IHRoaXMuc3VwcG9ydGVkQnJvd3NlcnMuaW5jbHVkZXMoYnJvd3Nlcik7XG4gICAgICAgIGlmICghdmFsaWRCcm93c2VyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChicm93c2VyID09PSBcImNocm9tZVwiKSByZXR1cm4gdmVyc2lvbiA+PSB0aGlzLm1pbkNocm9tZVZlcnNpb247XG4gICAgICAgIGlmIChicm93c2VyID09PSBcImZpcmVmb3hcIikgcmV0dXJuIHZlcnNpb24gPj0gdGhpcy5taW5GaXJlZm94VmVyc2lvbjtcbiAgICAgICAgaWYgKGJyb3dzZXIgPT09IFwic2FmYXJpXCIpIHJldHVybiAhdGhpcy5pc0lPUyAmJiB2ZXJzaW9uID49IHRoaXMubWluU2FmYXJpVmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRCcm93c2VyKCkge1xuICAgICAgICByZXR1cm4gJGZiNjNlNzY2Y2ZhZmFhYjkkdmFyJHdlYlJUQ0FkYXB0ZXIuYnJvd3NlckRldGFpbHMuYnJvd3NlcjtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICRmYjYzZTc2NmNmYWZhYWI5JHZhciR3ZWJSVENBZGFwdGVyLmJyb3dzZXJEZXRhaWxzLnZlcnNpb24gfHwgMDtcbiAgICB9XG4gICAgaXNVbmlmaWVkUGxhblN1cHBvcnRlZCgpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJGZiNjNlNzY2Y2ZhZmFhYjkkdmFyJHdlYlJUQ0FkYXB0ZXIuYnJvd3NlckRldGFpbHMudmVyc2lvbiB8fCAwO1xuICAgICAgICBpZiAoYnJvd3NlciA9PT0gXCJjaHJvbWVcIiAmJiB2ZXJzaW9uIDwgdGhpcy5taW5DaHJvbWVWZXJzaW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChicm93c2VyID09PSBcImZpcmVmb3hcIiAmJiB2ZXJzaW9uID49IHRoaXMubWluRmlyZWZveFZlcnNpb24pIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIXdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciB8fCAhKFwiY3VycmVudERpcmVjdGlvblwiIGluIFJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRlbXBQYztcbiAgICAgICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGVtcFBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB0ZW1wUGMuYWRkVHJhbnNjZWl2ZXIoXCJhdWRpb1wiKTtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHl7XG4gICAgICAgICAgICBpZiAodGVtcFBjKSB0ZW1wUGMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTdXBwb3J0czpcbiAgICBicm93c2VyOiR7dGhpcy5nZXRCcm93c2VyKCl9XG4gICAgdmVyc2lvbjoke3RoaXMuZ2V0VmVyc2lvbigpfVxuICAgIGlzSU9TOiR7dGhpcy5pc0lPU31cbiAgICBpc1dlYlJUQ1N1cHBvcnRlZDoke3RoaXMuaXNXZWJSVENTdXBwb3J0ZWQoKX1cbiAgICBpc0Jyb3dzZXJTdXBwb3J0ZWQ6JHt0aGlzLmlzQnJvd3NlclN1cHBvcnRlZCgpfVxuICAgIGlzVW5pZmllZFBsYW5TdXBwb3J0ZWQ6JHt0aGlzLmlzVW5pZmllZFBsYW5TdXBwb3J0ZWQoKX1gO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmlzSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFtcbiAgICAgICAgICAgIFwiaVBhZFwiLFxuICAgICAgICAgICAgXCJpUGhvbmVcIixcbiAgICAgICAgICAgIFwiaVBvZFwiXG4gICAgICAgIF0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZEJyb3dzZXJzID0gW1xuICAgICAgICAgICAgXCJmaXJlZm94XCIsXG4gICAgICAgICAgICBcImNocm9tZVwiLFxuICAgICAgICAgICAgXCJzYWZhcmlcIlxuICAgICAgICBdO1xuICAgICAgICB0aGlzLm1pbkZpcmVmb3hWZXJzaW9uID0gNTk7XG4gICAgICAgIHRoaXMubWluQ2hyb21lVmVyc2lvbiA9IDcyO1xuICAgICAgICB0aGlzLm1pblNhZmFyaVZlcnNpb24gPSA2MDU7XG4gICAgfVxufSgpO1xuXG5cbmNvbnN0ICQ5YTg0YTMyYmYwYmYzNmJiJGV4cG9ydCRmMzVmMTI4ZmQ1OWVhMjU2ID0gKGlkKT0+e1xuICAgIC8vIEFsbG93IGVtcHR5IGlkc1xuICAgIHJldHVybiAhaWQgfHwgL15bQS1aYS16MC05XSsoPzpbIF8tXVtBLVphLXowLTldKykqJC8udGVzdChpZCk7XG59O1xuXG5cbmNvbnN0ICQwZTVmZDE1ODU3ODRjMjUyJGV4cG9ydCQ0ZTYxZjY3MjkzNmJlYzc3ID0gKCk9Pk1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG5cbmNvbnN0ICQ0ZjQxMzQxNTZjNDQ2MzkyJHZhciRERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBpY2VTZXJ2ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6IFwic3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybHM6IFtcbiAgICAgICAgICAgICAgICBcInR1cm46ZXUtMC50dXJuLnBlZXJqcy5jb206MzQ3OFwiLFxuICAgICAgICAgICAgICAgIFwidHVybjp1cy0wLnR1cm4ucGVlcmpzLmNvbTozNDc4XCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB1c2VybmFtZTogXCJwZWVyanNcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWw6IFwicGVlcmpzcFwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIHNkcFNlbWFudGljczogXCJ1bmlmaWVkLXBsYW5cIlxufTtcbmNsYXNzICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCRmOGYyNmRkMzk1ZDdlMWJkIGV4dGVuZHMgKDAsICRmY2JjYzc1MzhhNjc3NmQ1JGV4cG9ydCRmMWM1ZjRjOWNiOTUzOTBiKSB7XG4gICAgbm9vcCgpIHt9XG4gICAgYmxvYlRvQXJyYXlCdWZmZXIoYmxvYiwgY2IpIHtcbiAgICAgICAgY29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGlmIChldnQudGFyZ2V0KSBjYihldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgICAgICByZXR1cm4gZnI7XG4gICAgfVxuICAgIGJpbmFyeVN0cmluZ1RvQXJyYXlCdWZmZXIoYmluYXJ5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKWJ5dGVBcnJheVtpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheS5idWZmZXI7XG4gICAgfVxuICAgIGlzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKSwgdGhpcy5DTE9VRF9IT1NUID0gXCIwLnBlZXJqcy5jb21cIiwgdGhpcy5DTE9VRF9QT1JUID0gNDQzLCAvLyBCcm93c2VycyB0aGF0IG5lZWQgY2h1bmtpbmc6XG4gICAgICAgIHRoaXMuY2h1bmtlZEJyb3dzZXJzID0ge1xuICAgICAgICAgICAgQ2hyb21lOiAxLFxuICAgICAgICAgICAgY2hyb21lOiAxXG4gICAgICAgIH0sIC8vIFJldHVybnMgYnJvd3Nlci1hZ25vc3RpYyBkZWZhdWx0IGNvbmZpZ1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSAkNGY0MTM0MTU2YzQ0NjM5MiR2YXIkREVGQVVMVF9DT05GSUcsIHRoaXMuYnJvd3NlciA9ICgwLCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCkuZ2V0QnJvd3NlcigpLCB0aGlzLmJyb3dzZXJWZXJzaW9uID0gKDAsICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkKS5nZXRWZXJzaW9uKCksIHRoaXMucGFjayA9ICRnQ2NiWSRwYWNrLCB0aGlzLnVucGFjayA9ICRnQ2NiWSR1bnBhY2ssIC8qKlxuXHQgKiBBIGhhc2ggb2YgV2ViUlRDIGZlYXR1cmVzIG1hcHBlZCB0byBib29sZWFucyB0aGF0IGNvcnJlc3BvbmQgdG8gd2hldGhlciB0aGUgZmVhdHVyZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICpcblx0ICogOjo6Y2F1dGlvblxuXHQgKiBPbmx5IHRoZSBwcm9wZXJ0aWVzIGRvY3VtZW50ZWQgaGVyZSBhcmUgZ3VhcmFudGVlZCB0byBiZSBwcmVzZW50IG9uIGB1dGlsLnN1cHBvcnRzYFxuXHQgKiA6Ojpcblx0ICovIHRoaXMuc3VwcG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IHtcbiAgICAgICAgICAgICAgICBicm93c2VyOiAoMCwgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QpLmlzQnJvd3NlclN1cHBvcnRlZCgpLFxuICAgICAgICAgICAgICAgIHdlYlJUQzogKDAsICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkKS5pc1dlYlJUQ1N1cHBvcnRlZCgpLFxuICAgICAgICAgICAgICAgIGF1ZGlvVmlkZW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJpbmFyeUJsb2I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbGlhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGVkLndlYlJUQykgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgICAgIGxldCBwYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oJDRmNDEzNDE1NmM0NDYzOTIkdmFyJERFRkFVTFRfQ09ORklHKTtcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWQuYXVkaW9WaWRlbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGRjO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoXCJfUEVFUkpTVEVTVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5yZWxpYWJsZSA9ICEhZGMub3JkZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmluYXJ5IHRlc3RcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRjLmJpbmFyeVR5cGUgPSBcImJsb2JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZC5iaW5hcnlCbG9iID0gISgwLCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCkuaXNJT1M7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge30gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRjKSBkYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgaWYgKHBjKSBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgfSgpLCAvLyBFbnN1cmUgYWxwaGFudW1lcmljIGlkc1xuICAgICAgICB0aGlzLnZhbGlkYXRlSWQgPSAoMCwgJDlhODRhMzJiZjBiZjM2YmIkZXhwb3J0JGYzNWYxMjhmZDU5ZWEyNTYpLCB0aGlzLnJhbmRvbVRva2VuID0gKDAsICQwZTVmZDE1ODU3ODRjMjUyJGV4cG9ydCQ0ZTYxZjY3MjkzNmJlYzc3KTtcbiAgICB9XG59XG5jb25zdCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYiA9IG5ldyAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkZjhmMjZkZDM5NWQ3ZTFiZCgpO1xuXG5cblxuY29uc3QgJDI1Nzk0N2U5MjkyNjI3N2EkdmFyJExPR19QUkVGSVggPSBcIlBlZXJKUzogXCI7XG52YXIgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDI0M2U2MmQ3OGQzYjU0NGQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKExvZ0xldmVsKSB7XG4gICAgLyoqXG5cdCAqIFByaW50cyBubyBsb2dzLlxuXHQgKi8gTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEaXNhYmxlZFwiXSA9IDBdID0gXCJEaXNhYmxlZFwiO1xuICAgIC8qKlxuXHQgKiBQcmludHMgb25seSBlcnJvcnMuXG5cdCAqLyBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yc1wiXSA9IDFdID0gXCJFcnJvcnNcIjtcbiAgICAvKipcblx0ICogUHJpbnRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG5cdCAqLyBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdzXCJdID0gMl0gPSBcIldhcm5pbmdzXCI7XG4gICAgLyoqXG5cdCAqIFByaW50cyBhbGwgbG9ncy5cblx0ICovIExvZ0xldmVsW0xvZ0xldmVsW1wiQWxsXCJdID0gM10gPSBcIkFsbFwiO1xuICAgIHJldHVybiBMb2dMZXZlbDtcbn0oe30pO1xuY2xhc3MgJDI1Nzk0N2U5MjkyNjI3N2EkdmFyJExvZ2dlciB7XG4gICAgZ2V0IGxvZ0xldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgfVxuICAgIHNldCBsb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgIH1cbiAgICBsb2coLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5fbG9nTGV2ZWwgPj0gMykgdGhpcy5fcHJpbnQoMywgLi4uYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5fbG9nTGV2ZWwgPj0gMikgdGhpcy5fcHJpbnQoMiwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvZ0xldmVsID49IDEpIHRoaXMuX3ByaW50KDEsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBzZXRMb2dGdW5jdGlvbihmbikge1xuICAgICAgICB0aGlzLl9wcmludCA9IGZuO1xuICAgIH1cbiAgICBfcHJpbnQobG9nTGV2ZWwsIC4uLnJlc3QpIHtcbiAgICAgICAgY29uc3QgY29weSA9IFtcbiAgICAgICAgICAgICQyNTc5NDdlOTI5MjYyNzdhJHZhciRMT0dfUFJFRklYLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICBdO1xuICAgICAgICBmb3IoY29uc3QgaSBpbiBjb3B5KWlmIChjb3B5W2ldIGluc3RhbmNlb2YgRXJyb3IpIGNvcHlbaV0gPSBcIihcIiArIGNvcHlbaV0ubmFtZSArIFwiKSBcIiArIGNvcHlbaV0ubWVzc2FnZTtcbiAgICAgICAgaWYgKGxvZ0xldmVsID49IDMpIGNvbnNvbGUubG9nKC4uLmNvcHkpO1xuICAgICAgICBlbHNlIGlmIChsb2dMZXZlbCA+PSAyKSBjb25zb2xlLndhcm4oXCJXQVJOSU5HXCIsIC4uLmNvcHkpO1xuICAgICAgICBlbHNlIGlmIChsb2dMZXZlbCA+PSAxKSBjb25zb2xlLmVycm9yKFwiRVJST1JcIiwgLi4uY29weSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gMDtcbiAgICB9XG59XG52YXIgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSA9IG5ldyAkMjU3OTQ3ZTkyOTI2Mjc3YSR2YXIkTG9nZ2VyKCk7XG5cblxudmFyICRjNGRjZmQxZDFlYTg2NjQ3JGV4cG9ydHMgPSB7fTtcbid1c2Ugc3RyaWN0JztcbnZhciAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA9ICd+Jztcbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRzKCkge31cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICAgICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvL1xuICAgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gICAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgICAvL1xuICAgIGlmICghbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKS5fX3Byb3RvX18pICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPSBmYWxzZTtcbn1cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGxpc3RlbmVyID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKSwgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gICAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW1xuICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XSxcbiAgICAgICAgbGlzdGVuZXJcbiAgICBdO1xuICAgIHJldHVybiBlbWl0dGVyO1xufVxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovIGZ1bmN0aW9uICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgIHZhciBuYW1lcyA9IFtdLCBldmVudHMsIG5hbWU7XG4gICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG4gICAgZm9yKG5hbWUgaW4gZXZlbnRzID0gdGhpcy5fZXZlbnRzKWlmICgkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaCgkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gICAgcmV0dXJuIG5hbWVzO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50LCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbXG4gICAgICAgIGhhbmRsZXJzLmZuXG4gICAgXTtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKyllZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICAgIHJldHVybiBlZTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgIHZhciBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgdmFyIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBpO1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIHN3aXRjaChsZW4pe1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsgaSA8IGxlbjsgaSsrKWFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoLCBqO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHN3aXRjaChsZW4pe1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIGZvcihqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsgaiA8IGxlbjsgaisrKWFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJGM0ZGNmZDFkMWVhODY2NDckdmFyJGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgdmFyIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWZuKSB7XG4gICAgICAgICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgICBpZiAobGlzdGVuZXJzLmZuID09PSBmbiAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dCkpICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKylpZiAobGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fCBvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSB8fCBjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KSBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgICAgIGVsc2UgJGM0ZGNmZDFkMWVhODY2NDckdmFyJGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0O1xuICAgIGlmIChldmVudCkge1xuICAgICAgICBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgJGM0ZGNmZDFkMWVhODY2NDckdmFyJGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbiRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG4kYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeDtcbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbiRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlcjtcbiRjNGRjZmQxZDFlYTg2NjQ3JGV4cG9ydHMgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyO1xuXG5cblxudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJDb25uZWN0aW9uVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlBlZXJFcnJvclR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJCYXNlQ29ubmVjdGlvbkVycm9yVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4Nik7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIkRhdGFDb25uZWN0aW9uRXJyb3JUeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkKTtcbiRwYXJjZWwkZXhwb3J0KCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMsIFwiU2VyaWFsaXphdGlvblR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0Nyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlNvY2tldEV2ZW50VHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlNlcnZlck1lc3NhZ2VUeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29ubmVjdGlvblR5cGUpIHtcbiAgICBDb25uZWN0aW9uVHlwZVtcIkRhdGFcIl0gPSBcImRhdGFcIjtcbiAgICBDb25uZWN0aW9uVHlwZVtcIk1lZGlhXCJdID0gXCJtZWRpYVwiO1xuICAgIHJldHVybiBDb25uZWN0aW9uVHlwZTtcbn0oe30pO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihQZWVyRXJyb3JUeXBlKSB7XG4gICAgLyoqXG5cdCAqIFRoZSBjbGllbnQncyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgc29tZSBvciBhbGwgV2ViUlRDIGZlYXR1cmVzIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gdXNlLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkJyb3dzZXJJbmNvbXBhdGlibGVcIl0gPSBcImJyb3dzZXItaW5jb21wYXRpYmxlXCI7XG4gICAgLyoqXG5cdCAqIFlvdSd2ZSBhbHJlYWR5IGRpc2Nvbm5lY3RlZCB0aGlzIHBlZXIgZnJvbSB0aGUgc2VydmVyIGFuZCBjYW4gbm8gbG9uZ2VyIG1ha2UgYW55IG5ldyBjb25uZWN0aW9ucyBvbiBpdC5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIC8qKlxuXHQgKiBUaGUgSUQgcGFzc2VkIGludG8gdGhlIFBlZXIgY29uc3RydWN0b3IgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkludmFsaWRJRFwiXSA9IFwiaW52YWxpZC1pZFwiO1xuICAgIC8qKlxuXHQgKiBUaGUgQVBJIGtleSBwYXNzZWQgaW50byB0aGUgUGVlciBjb25zdHJ1Y3RvciBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgb3IgaXMgbm90IGluIHRoZSBzeXN0ZW0gKGNsb3VkIHNlcnZlciBvbmx5KS5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJJbnZhbGlkS2V5XCJdID0gXCJpbnZhbGlkLWtleVwiO1xuICAgIC8qKlxuXHQgKiBMb3N0IG9yIGNhbm5vdCBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlci5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJOZXR3b3JrXCJdID0gXCJuZXR3b3JrXCI7XG4gICAgLyoqXG5cdCAqIFRoZSBwZWVyIHlvdSdyZSB0cnlpbmcgdG8gY29ubmVjdCB0byBkb2VzIG5vdCBleGlzdC5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJQZWVyVW5hdmFpbGFibGVcIl0gPSBcInBlZXItdW5hdmFpbGFibGVcIjtcbiAgICAvKipcblx0ICogUGVlckpTIGlzIGJlaW5nIHVzZWQgc2VjdXJlbHksIGJ1dCB0aGUgY2xvdWQgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgU1NMLiBVc2UgYSBjdXN0b20gUGVlclNlcnZlci5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJTc2xVbmF2YWlsYWJsZVwiXSA9IFwic3NsLXVuYXZhaWxhYmxlXCI7XG4gICAgLyoqXG5cdCAqIFVuYWJsZSB0byByZWFjaCB0aGUgc2VydmVyLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlNlcnZlckVycm9yXCJdID0gXCJzZXJ2ZXItZXJyb3JcIjtcbiAgICAvKipcblx0ICogQW4gZXJyb3IgZnJvbSB0aGUgdW5kZXJseWluZyBzb2NrZXQuXG5cdCAqLyBQZWVyRXJyb3JUeXBlW1wiU29ja2V0RXJyb3JcIl0gPSBcInNvY2tldC1lcnJvclwiO1xuICAgIC8qKlxuXHQgKiBUaGUgdW5kZXJseWluZyBzb2NrZXQgY2xvc2VkIHVuZXhwZWN0ZWRseS5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJTb2NrZXRDbG9zZWRcIl0gPSBcInNvY2tldC1jbG9zZWRcIjtcbiAgICAvKipcblx0ICogVGhlIElEIHBhc3NlZCBpbnRvIHRoZSBQZWVyIGNvbnN0cnVjdG9yIGlzIGFscmVhZHkgdGFrZW4uXG5cdCAqXG5cdCAqIDo6OmNhdXRpb25cblx0ICogVGhpcyBlcnJvciBpcyBub3QgZmF0YWwgaWYgeW91ciBwZWVyIGhhcyBvcGVuIHBlZXItdG8tcGVlciBjb25uZWN0aW9ucy5cblx0ICogVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhdHRlbXB0IHRvIHtAYXBpbGluayBQZWVyLnJlY29ubmVjdH0gYSBwZWVyIHRoYXQgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlcixcblx0ICogYnV0IGl0cyBvbGQgSUQgaGFzIG5vdyBiZWVuIHRha2VuLlxuXHQgKiA6Ojpcblx0ICovIFBlZXJFcnJvclR5cGVbXCJVbmF2YWlsYWJsZUlEXCJdID0gXCJ1bmF2YWlsYWJsZS1pZFwiO1xuICAgIC8qKlxuXHQgKiBOYXRpdmUgV2ViUlRDIGVycm9ycy5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJXZWJSVENcIl0gPSBcIndlYnJ0Y1wiO1xuICAgIHJldHVybiBQZWVyRXJyb3JUeXBlO1xufSh7fSk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlKSB7XG4gICAgQmFzZUNvbm5lY3Rpb25FcnJvclR5cGVbXCJOZWdvdGlhdGlvbkZhaWxlZFwiXSA9IFwibmVnb3RpYXRpb24tZmFpbGVkXCI7XG4gICAgQmFzZUNvbm5lY3Rpb25FcnJvclR5cGVbXCJDb25uZWN0aW9uQ2xvc2VkXCJdID0gXCJjb25uZWN0aW9uLWNsb3NlZFwiO1xuICAgIHJldHVybiBCYXNlQ29ubmVjdGlvbkVycm9yVHlwZTtcbn0oe30pO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihEYXRhQ29ubmVjdGlvbkVycm9yVHlwZSkge1xuICAgIERhdGFDb25uZWN0aW9uRXJyb3JUeXBlW1wiTm90T3BlbllldFwiXSA9IFwibm90LW9wZW4teWV0XCI7XG4gICAgRGF0YUNvbm5lY3Rpb25FcnJvclR5cGVbXCJNZXNzYWdlVG9CaWdcIl0gPSBcIm1lc3NhZ2UtdG9vLWJpZ1wiO1xuICAgIHJldHVybiBEYXRhQ29ubmVjdGlvbkVycm9yVHlwZTtcbn0oe30pO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ4OWY1MDdjZjk4NmE5NDcgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgU2VyaWFsaXphdGlvblR5cGVbXCJCaW5hcnlcIl0gPSBcImJpbmFyeVwiO1xuICAgIFNlcmlhbGl6YXRpb25UeXBlW1wiQmluYXJ5VVRGOFwiXSA9IFwiYmluYXJ5LXV0ZjhcIjtcbiAgICBTZXJpYWxpemF0aW9uVHlwZVtcIkpTT05cIl0gPSBcImpzb25cIjtcbiAgICBTZXJpYWxpemF0aW9uVHlwZVtcIk5vbmVcIl0gPSBcInJhd1wiO1xuICAgIHJldHVybiBTZXJpYWxpemF0aW9uVHlwZTtcbn0oe30pO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihTb2NrZXRFdmVudFR5cGUpIHtcbiAgICBTb2NrZXRFdmVudFR5cGVbXCJNZXNzYWdlXCJdID0gXCJtZXNzYWdlXCI7XG4gICAgU29ja2V0RXZlbnRUeXBlW1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBTb2NrZXRFdmVudFR5cGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBTb2NrZXRFdmVudFR5cGVbXCJDbG9zZVwiXSA9IFwiY2xvc2VcIjtcbiAgICByZXR1cm4gU29ja2V0RXZlbnRUeXBlO1xufSh7fSk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFNlcnZlck1lc3NhZ2VUeXBlKSB7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJIZWFydGJlYXRcIl0gPSBcIkhFQVJUQkVBVFwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiQ2FuZGlkYXRlXCJdID0gXCJDQU5ESURBVEVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIk9mZmVyXCJdID0gXCJPRkZFUlwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiQW5zd2VyXCJdID0gXCJBTlNXRVJcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIk9wZW5cIl0gPSBcIk9QRU5cIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkVycm9yXCJdID0gXCJFUlJPUlwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiSWRUYWtlblwiXSA9IFwiSUQtVEFLRU5cIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkludmFsaWRLZXlcIl0gPSBcIklOVkFMSUQtS0VZXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJMZWF2ZVwiXSA9IFwiTEVBVkVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkV4cGlyZVwiXSA9IFwiRVhQSVJFXCI7XG4gICAgcmV0dXJuIFNlcnZlck1lc3NhZ2VUeXBlO1xufSh7fSk7XG5cblxuY29uc3QgJDUyMDgzMmQ0NGJhMDU4YzgkZXhwb3J0JDgzZDg5ZmJmZDgyMzY0OTIgPSBcIjEuNS41XCI7XG5cblxuY2xhc3MgJDhmNWJmYTYwODM2ZDI2MWQkZXhwb3J0JDQ3OTg5MTdkYmYxNDliNzkgZXh0ZW5kcyAoMCwgJGM0ZGNmZDFkMWVhODY2NDckZXhwb3J0cy5FdmVudEVtaXR0ZXIpIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmUsIGhvc3QsIHBvcnQsIHBhdGgsIGtleSwgcGluZ0ludGVydmFsID0gNTAwMCl7XG4gICAgICAgIHN1cGVyKCksIHRoaXMucGluZ0ludGVydmFsID0gcGluZ0ludGVydmFsLCB0aGlzLl9kaXNjb25uZWN0ZWQgPSB0cnVlLCB0aGlzLl9tZXNzYWdlc1F1ZXVlID0gW107XG4gICAgICAgIGNvbnN0IHdzUHJvdG9jb2wgPSBzZWN1cmUgPyBcIndzczovL1wiIDogXCJ3czovL1wiO1xuICAgICAgICB0aGlzLl9iYXNlVXJsID0gd3NQcm90b2NvbCArIGhvc3QgKyBcIjpcIiArIHBvcnQgKyBwYXRoICsgXCJwZWVyanM/a2V5PVwiICsga2V5O1xuICAgIH1cbiAgICBzdGFydChpZCwgdG9rZW4pIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgY29uc3Qgd3NVcmwgPSBgJHt0aGlzLl9iYXNlVXJsfSZpZD0ke2lkfSZ0b2tlbj0ke3Rva2VufWA7XG4gICAgICAgIGlmICghIXRoaXMuX3NvY2tldCB8fCAhdGhpcy5fZGlzY29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3NvY2tldCA9IG5ldyBXZWJTb2NrZXQod3NVcmwgKyBcIiZ2ZXJzaW9uPVwiICsgKDAsICQ1MjA4MzJkNDRiYTA1OGM4JGV4cG9ydCQ4M2Q4OWZiZmQ4MjM2NDkyKSk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJTZXJ2ZXIgbWVzc2FnZSByZWNlaXZlZDpcIiwgZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkludmFsaWQgc2VydmVyIG1lc3NhZ2VcIiwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuTWVzc2FnZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbmNsb3NlID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNvY2tldCBjbG9zZWQuXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5EaXNjb25uZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUYWtlIGNhcmUgb2YgdGhlIHF1ZXVlIG9mIGNvbm5lY3Rpb25zIGlmIG5lY2Vzc2FyeSBhbmQgbWFrZSBzdXJlIFBlZXIga25vd3NcbiAgICAgICAgLy8gc29ja2V0IGlzIG9wZW4uXG4gICAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiU29ja2V0IG9wZW5cIik7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZUhlYXJ0YmVhdCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2NoZWR1bGVIZWFydGJlYXQoKSB7XG4gICAgICAgIHRoaXMuX3dzUGluZ1RpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5fc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICAgIF9zZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dzT3BlbigpKSB7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBDYW5ub3Qgc2VuZCBoZWFydGJlYXQsIGJlY2F1c2Ugc29ja2V0IGNsb3NlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkhlYXJ0YmVhdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlSGVhcnRiZWF0KCk7XG4gICAgfVxuICAgIC8qKiBJcyB0aGUgd2Vic29ja2V0IGN1cnJlbnRseSBvcGVuPyAqLyBfd3NPcGVuKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT09IDE7XG4gICAgfVxuICAgIC8qKiBTZW5kIHF1ZXVlZCBtZXNzYWdlcy4gKi8gX3NlbmRRdWV1ZWRNZXNzYWdlcygpIHtcbiAgICAgICAgLy9DcmVhdGUgY29weSBvZiBxdWV1ZSBhbmQgY2xlYXIgaXQsXG4gICAgICAgIC8vYmVjYXVzZSBzZW5kIG1ldGhvZCBwdXNoIHRoZSBtZXNzYWdlIGJhY2sgdG8gcXVldWUgaWYgc210aCB3aWxsIGdvIHdyb25nXG4gICAgICAgIGNvbnN0IGNvcGllZFF1ZXVlID0gW1xuICAgICAgICAgICAgLi4udGhpcy5fbWVzc2FnZXNRdWV1ZVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlc1F1ZXVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb3BpZWRRdWV1ZSl0aGlzLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKiBFeHBvc2VkIHNlbmQgZm9yIERDICYgUGVlci4gKi8gc2VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNjb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBJRCB5ZXQsIHdlIGNhbid0IHlldCBzZW5kIGFueXRoaW5nIHNvIHdlIHNob3VsZCBxdWV1ZVxuICAgICAgICAvLyB1cCB0aGVzZSBtZXNzYWdlcy5cbiAgICAgICAgaWYgKCF0aGlzLl9pZCkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXNRdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5FcnJvciwgXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl93c09wZW4oKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQub25vcGVuID0gdGhpcy5fc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX3NvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93c1BpbmdUaW1lcik7XG4gICAgfVxufVxuXG5cblxuXG5cblxuY2xhc3MgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbil7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgUGVlckNvbm5lY3Rpb24gb2JqZWN0IHNldCB1cCBjb3JyZWN0bHkgKGZvciBkYXRhLCBtZWRpYSkuICovIHN0YXJ0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5fc3RhcnRQZWVyQ29ubmVjdGlvbigpO1xuICAgICAgICAvLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBQQy5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uID0gcGVlckNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5NZWRpYSAmJiBvcHRpb25zLl9zdHJlYW0pIHRoaXMuX2FkZFRyYWNrc1RvQ29ubmVjdGlvbihvcHRpb25zLl9zdHJlYW0sIHBlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgLy8gV2hhdCBkbyB3ZSBuZWVkIHRvIGRvIG5vdz9cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luYXRvcikge1xuICAgICAgICAgICAgY29uc3QgZGF0YUNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZDogISFvcHRpb25zLnJlbGlhYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSBwZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChkYXRhQ29ubmVjdGlvbi5sYWJlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGRhdGFDb25uZWN0aW9uLl9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgICAgICAgICAgdGhpcy5fbWFrZU9mZmVyKCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmhhbmRsZVNEUChcIk9GRkVSXCIsIG9wdGlvbnMuc2RwKTtcbiAgICB9XG4gICAgLyoqIFN0YXJ0IGEgUEMuICovIF9zdGFydFBlZXJDb25uZWN0aW9uKCkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiQ3JlYXRpbmcgUlRDUGVlckNvbm5lY3Rpb24uXCIpO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIub3B0aW9ucy5jb25maWcpO1xuICAgICAgICB0aGlzLl9zZXR1cExpc3RlbmVycyhwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqIFNldCB1cCB2YXJpb3VzIFdlYlJUQyBsaXN0ZW5lcnMuICovIF9zZXR1cExpc3RlbmVycyhwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwZWVySWQgPSB0aGlzLmNvbm5lY3Rpb24ucGVlcjtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblR5cGUgPSB0aGlzLmNvbm5lY3Rpb24udHlwZTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXI7XG4gICAgICAgIC8vIElDRSBDQU5ESURBVEVTLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciBJQ0UgY2FuZGlkYXRlcy5cIik7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2dCk9PntcbiAgICAgICAgICAgIGlmICghZXZ0LmNhbmRpZGF0ZSB8fCAhZXZ0LmNhbmRpZGF0ZS5jYW5kaWRhdGUpIHJldHVybjtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFJlY2VpdmVkIElDRSBjYW5kaWRhdGVzIGZvciAke3BlZXJJZH06YCwgZXZ0LmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBwcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5DYW5kaWRhdGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGU6IGV2dC5jYW5kaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHN0OiBwZWVySWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpPT57XG4gICAgICAgICAgICBzd2l0Y2gocGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJpY2VDb25uZWN0aW9uU3RhdGUgaXMgZmFpbGVkLCBjbG9zaW5nIGNvbm5lY3Rpb25zIHRvIFwiICsgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYpLk5lZ290aWF0aW9uRmFpbGVkLCBcIk5lZ290aWF0aW9uIG9mIGNvbm5lY3Rpb24gdG8gXCIgKyBwZWVySWQgKyBcIiBmYWlsZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiaWNlQ29ubmVjdGlvblN0YXRlIGlzIGNsb3NlZCwgY2xvc2luZyBjb25uZWN0aW9ucyB0byBcIiArIHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2KS5Db25uZWN0aW9uQ2xvc2VkLCBcIkNvbm5lY3Rpb24gdG8gXCIgKyBwZWVySWQgKyBcIiBjbG9zZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiaWNlQ29ubmVjdGlvblN0YXRlIGNoYW5nZWQgdG8gZGlzY29ubmVjdGVkIG9uIHRoZSBjb25uZWN0aW9uIHdpdGggXCIgKyBwZWVySWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKCk9Pnt9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5lbWl0KFwiaWNlU3RhdGVDaGFuZ2VkXCIsIHBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIERBVEFDT05ORUNUSU9OLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciBkYXRhIGNoYW5uZWxcIik7XG4gICAgICAgIC8vIEZpcmVkIGJldHdlZW4gb2ZmZXIgYW5kIGFuc3dlciwgc28gb3B0aW9ucyBzaG91bGQgYWxyZWFkeSBiZSBzYXZlZFxuICAgICAgICAvLyBpbiB0aGUgb3B0aW9ucyBoYXNoLlxuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gKGV2dCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJSZWNlaXZlZCBkYXRhIGNoYW5uZWxcIik7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IGV2dC5jaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRhdGFDaGFubmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTUVESUFDT05ORUNUSU9OLlxuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiTGlzdGVuaW5nIGZvciByZW1vdGUgc3RyZWFtXCIpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gKGV2dCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJSZWNlaXZlZCByZW1vdGUgc3RyZWFtXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZXZ0LnN0cmVhbXNbMF07XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gcHJvdmlkZXIuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVkaWFDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRTdHJlYW1Ub01lZGlhQ29ubmVjdGlvbihzdHJlYW0sIG1lZGlhQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJDbGVhbmluZyB1cCBQZWVyQ29ubmVjdGlvbiB0byBcIiArIHRoaXMuY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb247XG4gICAgICAgIGlmICghcGVlckNvbm5lY3Rpb24pIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy91bnN1YnNjcmliZSBmcm9tIGFsbCBQZWVyQ29ubmVjdGlvbidzIGV2ZW50c1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gcGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSAoKT0+e307XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uTm90Q2xvc2VkID0gcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IFwiY2xvc2VkXCI7XG4gICAgICAgIGxldCBkYXRhQ2hhbm5lbE5vdENsb3NlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuY29ubmVjdGlvbi5kYXRhQ2hhbm5lbDtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsKSBkYXRhQ2hhbm5lbE5vdENsb3NlZCA9ICEhZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSAmJiBkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiO1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25Ob3RDbG9zZWQgfHwgZGF0YUNoYW5uZWxOb3RDbG9zZWQpIHBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGFzeW5jIF9tYWtlT2ZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIodGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuY29uc3RyYWludHMpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkNyZWF0ZWQgb2ZmZXIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybSAmJiB0eXBlb2YgdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIpIG9mZmVyLnNkcCA9IHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybShvZmZlci5zZHApIHx8IG9mZmVyLnNkcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNldCBsb2NhbERlc2NyaXB0aW9uOlwiLCBvZmZlciwgYGZvcjoke3RoaXMuY29ubmVjdGlvbi5wZWVyfWApO1xuICAgICAgICAgICAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBzZHA6IG9mZmVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5jb25uZWN0aW9uLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnR5cGUgPT09ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYykuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGF0YUNvbm5lY3Rpb24ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxpYWJsZTogZGF0YUNvbm5lY3Rpb24ucmVsaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBkYXRhQ29ubmVjdGlvbi5zZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNvY2tldC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5PZmZlcixcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZHN0OiB0aGlzLmNvbm5lY3Rpb24ucGVlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IF9tYWtlT2ZmZXIgaXMgYmVpbmcgY2FsbGVkIGZyb20gdGhlIGFuc3dlclxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gXCJPcGVyYXRpb25FcnJvcjogRmFpbGVkIHRvIHNldCBsb2NhbCBvZmZlciBzZHA6IENhbGxlZCBpbiB3cm9uZyBzdGF0ZToga0hhdmVSZW1vdGVPZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkZhaWxlZCB0byBzZXRMb2NhbERlc2NyaXB0aW9uLCBcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycl8xKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycl8xKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJGYWlsZWQgdG8gY3JlYXRlT2ZmZXIsIFwiLCBlcnJfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX21ha2VBbnN3ZXIoKSB7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkNyZWF0ZWQgYW5zd2VyLlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ub3B0aW9ucy5zZHBUcmFuc2Zvcm0gJiYgdHlwZW9mIHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiKSBhbnN3ZXIuc2RwID0gdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApIHx8IGFuc3dlci5zZHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBTZXQgbG9jYWxEZXNjcmlwdGlvbjpgLCBhbnN3ZXIsIGBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuQW5zd2VyLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZHA6IGFuc3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuY29ubmVjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvbklkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRzdDogdGhpcy5jb25uZWN0aW9uLnBlZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyKTtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIHNldExvY2FsRGVzY3JpcHRpb24sIFwiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJfMSkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnJfMSk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIGNyZWF0ZSBhbnN3ZXIsIFwiLCBlcnJfMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEhhbmRsZSBhbiBTRFAuICovIGFzeW5jIGhhbmRsZVNEUCh0eXBlLCBzZHApIHtcbiAgICAgICAgc2RwID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXI7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJTZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvblwiLCBzZHApO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcCk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBTZXQgcmVtb3RlRGVzY3JpcHRpb246JHt0eXBlfSBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9GRkVSXCIpIGF3YWl0IHNlbGYuX21ha2VBbnN3ZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycik7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIHNldFJlbW90ZURlc2NyaXB0aW9uLCBcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSGFuZGxlIGEgY2FuZGlkYXRlLiAqLyBhc3luYyBoYW5kbGVDYW5kaWRhdGUoaWNlKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGhhbmRsZUNhbmRpZGF0ZTpgLCBpY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShpY2UpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgQWRkZWQgSUNFIGNhbmRpZGF0ZSBmb3I6JHt0aGlzLmNvbm5lY3Rpb24ucGVlcn1gKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnIpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkZhaWxlZCB0byBoYW5kbGVDYW5kaWRhdGUsIFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRUcmFja3NUb0Nvbm5lY3Rpb24oc3RyZWFtLCBwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBhZGQgdHJhY2tzIGZyb20gc3RyZWFtICR7c3RyZWFtLmlkfSB0byBwZWVyIGNvbm5lY3Rpb25gKTtcbiAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbi5hZGRUcmFjaykgcmV0dXJuICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihgWW91ciBicm93c2VyIGRvZXMndCBzdXBwb3J0IFJUQ1BlZXJDb25uZWN0aW9uI2FkZFRyYWNrLiBJZ25vcmVkLmApO1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spPT57XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRUcmFjayh0cmFjaywgc3RyZWFtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRTdHJlYW1Ub01lZGlhQ29ubmVjdGlvbihzdHJlYW0sIG1lZGlhQ29ubmVjdGlvbikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBhZGQgc3RyZWFtICR7c3RyZWFtLmlkfSB0byBtZWRpYSBjb25uZWN0aW9uICR7bWVkaWFDb25uZWN0aW9uLmNvbm5lY3Rpb25JZH1gKTtcbiAgICAgICAgbWVkaWFDb25uZWN0aW9uLmFkZFN0cmVhbShzdHJlYW0pO1xuICAgIH1cbn1cblxuXG5cblxuXG5jbGFzcyAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkNmE2NzhlNTg5YzhhNDU0MiBleHRlbmRzICgwLCAkYzRkY2ZkMWQxZWE4NjY0NyRleHBvcnRzLkV2ZW50RW1pdHRlcikge1xuICAgIC8qKlxuXHQgKiBFbWl0cyBhIHR5cGVkIGVycm9yIG1lc3NhZ2UuXG5cdCAqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi8gZW1pdEVycm9yKHR5cGUsIGVycikge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoXCJFcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgJDIzNzc5ZDE4ODExNTdhMTgkZXhwb3J0JDk4ODcxODgyZjQ5MmRlODIoYCR7dHlwZX1gLCBlcnIpKTtcbiAgICB9XG59XG5jbGFzcyAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkOTg4NzE4ODJmNDkyZGU4MiBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcblx0ICogQGludGVybmFsXG5cdCAqLyBjb25zdHJ1Y3Rvcih0eXBlLCBlcnIpe1xuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikgc3VwZXIoZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5cbmNsYXNzICQ1MDQ1MTkyZmM2ZDM4N2JhJGV4cG9ydCQyM2EyYTY4MjgzYzI0ZDgwIGV4dGVuZHMgKDAsICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ2YTY3OGU1ODljOGE0NTQyKSB7XG4gICAgLyoqXG5cdCAqIFdoZXRoZXIgdGhlIG1lZGlhIGNvbm5lY3Rpb24gaXMgYWN0aXZlIChlLmcuIHlvdXIgY2FsbCBoYXMgYmVlbiBhbnN3ZXJlZCkuXG5cdCAqIFlvdSBjYW4gY2hlY2sgdGhpcyBpZiB5b3Ugd2FudCB0byBzZXQgYSBtYXhpbXVtIHdhaXQgdGltZSBmb3IgYSBvbmUtc2lkZWQgY2FsbC5cblx0ICovIGdldCBvcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLyoqXG5cdFx0ICogVGhlIElEIG9mIHRoZSBwZWVyIG9uIHRoZSBvdGhlciBlbmQgb2YgdGhpcyBjb25uZWN0aW9uLlxuXHRcdCAqLyBwZWVyLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKCksIHRoaXMucGVlciA9IHBlZXIsIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlciwgdGhpcy5vcHRpb25zID0gb3B0aW9ucywgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDVjMWQwOGM3YzU3ZGE5YTMkZXhwb3J0JDRhODRlOTVhMjMyNGFjMjkgZXh0ZW5kcyAoMCwgJDUwNDUxOTJmYzZkMzg3YmEkZXhwb3J0JDIzYTJhNjgyODNjMjRkODApIHtcbiAgICBzdGF0aWMgI18gPSB0aGlzLklEX1BSRUZJWCA9IFwibWNfXCI7XG4gICAgLyoqXG5cdCAqIEZvciBtZWRpYSBjb25uZWN0aW9ucywgdGhpcyBpcyBhbHdheXMgJ21lZGlhJy5cblx0ICovIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5NZWRpYTtcbiAgICB9XG4gICAgZ2V0IGxvY2FsU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW07XG4gICAgfVxuICAgIGdldCByZW1vdGVTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW0gPSB0aGlzLm9wdGlvbnMuX3N0cmVhbTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSWQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbklkIHx8ICQ1YzFkMDhjN2M1N2RhOWEzJGV4cG9ydCQ0YTg0ZTk1YTIzMjRhYzI5LklEX1BSRUZJWCArICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikucmFuZG9tVG9rZW4oKTtcbiAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG5ldyAoMCwgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFN0cmVhbSkgdGhpcy5fbmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgX3N0cmVhbTogdGhpcy5fbG9jYWxTdHJlYW0sXG4gICAgICAgICAgICBvcmlnaW5hdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSBOZWdvdGlhdG9yIHdoZW4gdGhlIERhdGFDaGFubmVsIGlzIHJlYWR5LiAqLyBfaW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSBkYztcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgREMjJHt0aGlzLmNvbm5lY3Rpb25JZH0gZGMgY29ubmVjdGlvbiBzdWNjZXNzYCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ3aWxsQ2xvc2VPblJlbW90ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIGNsb3NlZCBmb3I6YCwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkU3RyZWFtKHJlbW90ZVN0cmVhbSkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiUmVjZWl2aW5nIHN0cmVhbVwiLCByZW1vdGVTdHJlYW0pO1xuICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW0gPSByZW1vdGVTdHJlYW07XG4gICAgICAgIHN1cGVyLmVtaXQoXCJzdHJlYW1cIiwgcmVtb3RlU3RyZWFtKTsgLy8gU2hvdWxkIHdlIGNhbGwgdGhpcyBgb3BlbmA/XG4gICAgfVxuICAgIC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS50eXBlO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICBzd2l0Y2gobWVzc2FnZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5BbnN3ZXI6XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCB0byBuZWdvdGlhdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvci5oYW5kbGVTRFAodHlwZSwgcGF5bG9hZC5zZHApO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkNhbmRpZGF0ZTpcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZUNhbmRpZGF0ZShwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBVbnJlY29nbml6ZWQgbWVzc2FnZSB0eXBlOiR7dHlwZX0gZnJvbSBwZWVyOiR7dGhpcy5wZWVyfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gcmVjZWl2aW5nIGEge0BhcGlsaW5rIFBlZXJFdmVudHMgfCBgY2FsbGB9IGV2ZW50IG9uIGEgcGVlciwgeW91IGNhbiBjYWxsXG4gICAgICogYGFuc3dlcmAgb24gdGhlIG1lZGlhIGNvbm5lY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGNhbGxiYWNrIHRvIGFjY2VwdCB0aGUgY2FsbFxuICAgICAqIGFuZCBvcHRpb25hbGx5IHNlbmQgeW91ciBvd24gbWVkaWEgc3RyZWFtLlxuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyZWFtIEEgV2ViUlRDIG1lZGlhIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovIGFuc3dlcihzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiTG9jYWwgc3RyZWFtIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgTWVkaWFDb25uZWN0aW9uLiBBcmUgeW91IGFuc3dlcmluZyBhIGNhbGwgdHdpY2U/XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNkcFRyYW5zZm9ybSkgdGhpcy5vcHRpb25zLnNkcFRyYW5zZm9ybSA9IG9wdGlvbnMuc2RwVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuX3BheWxvYWQsXG4gICAgICAgICAgICBfc3RyZWFtOiBzdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHJpZXZlIGxvc3QgbWVzc2FnZXMgc3RvcmVkIGJlY2F1c2UgUGVlckNvbm5lY3Rpb24gbm90IHNldCB1cC5cbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnByb3ZpZGVyLl9nZXRNZXNzYWdlcyh0aGlzLmNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcyl0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgIH1cbiAgICAvKipcblx0ICogRXhwb3NlZCBmdW5jdGlvbmFsaXR5IGZvciB1c2Vycy5cblx0ICovIC8qKlxuXHQgKiBDbG9zZXMgdGhlIG1lZGlhIGNvbm5lY3Rpb24uXG5cdCAqLyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25lZ290aWF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZ290aWF0b3IuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW0gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fcmVtb3ZlQ29ubmVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLl9zdHJlYW0pIHRoaXMub3B0aW9ucy5fc3RyZWFtID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybjtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICBzdXBlci5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxufVxuXG5cblxuXG5cblxuY2xhc3MgJGFiZjI2NjY0MTkyN2NkODkkZXhwb3J0JDJjNGU4MjVkYzkxMjBmODcge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKXtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICBfYnVpbGRSZXF1ZXN0KG1ldGhvZCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMuX29wdGlvbnMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgIGNvbnN0IHsgaG9zdDogaG9zdCwgcG9ydDogcG9ydCwgcGF0aDogcGF0aCwga2V5OiBrZXkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7cHJvdG9jb2x9Oi8vJHtob3N0fToke3BvcnR9JHtwYXRofSR7a2V5fS8ke21ldGhvZH1gKTtcbiAgICAgICAgLy8gVE9ETzogV2h5IHRpbWVzdGFtcCwgd2h5IHJhbmRvbT9cbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0c1wiLCBgJHtEYXRlLm5vdygpfSR7TWF0aC5yYW5kb20oKX1gKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsICgwLCAkNTIwODMyZDQ0YmEwNThjOCRleHBvcnQkODNkODlmYmZkODIzNjQ5MikpO1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiB0aGlzLl9vcHRpb25zLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogR2V0IGEgdW5pcXVlIElEIGZyb20gdGhlIHNlcnZlciB2aWEgWEhSIGFuZCBpbml0aWFsaXplIHdpdGggaXQuICovIGFzeW5jIHJldHJpZXZlSWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2J1aWxkUmVxdWVzdChcImlkXCIpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB0aHJvdyBuZXcgRXJyb3IoYEVycm9yLiBTdGF0dXM6JHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBJRFwiLCBlcnJvcik7XG4gICAgICAgICAgICBsZXQgcGF0aEVycm9yID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhdGggPT09IFwiL1wiICYmIHRoaXMuX29wdGlvbnMuaG9zdCAhPT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSBwYXRoRXJyb3IgPSBcIiBJZiB5b3UgcGFzc2VkIGluIGEgYHBhdGhgIHRvIHlvdXIgc2VsZi1ob3N0ZWQgUGVlclNlcnZlciwgeW91J2xsIGFsc28gbmVlZCB0byBwYXNzIGluIHRoYXQgc2FtZSBwYXRoIHdoZW4gY3JlYXRpbmcgYSBuZXcgUGVlci5cIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgYW4gSUQgZnJvbSB0aGUgc2VydmVyLlwiICsgcGF0aEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi8gYXN5bmMgbGlzdEFsbFBlZXJzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9idWlsZFJlcXVlc3QoXCJwZWVyc1wiKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVscGZ1bEVycm9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaG9zdCA9PT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSBoZWxwZnVsRXJyb3IgPSBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBjbG91ZCBzZXJ2ZXIuIFlvdSBjYW4gZW1haWwgdGVhbUBwZWVyanMuY29tIHRvIGVuYWJsZSBwZWVyIGxpc3RpbmcgZm9yIHlvdXIgQVBJIGtleS5cIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBoZWxwZnVsRXJyb3IgPSBcIllvdSBuZWVkIHRvIGVuYWJsZSBgYWxsb3dfZGlzY292ZXJ5YCBvbiB5b3VyIHNlbGYtaG9zdGVkIFBlZXJTZXJ2ZXIgdG8gdXNlIHRoaXMgZmVhdHVyZS5cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgZG9lc24ndCBsb29rIGxpa2UgeW91IGhhdmUgcGVybWlzc2lvbiB0byBsaXN0IHBlZXJzIElEcy4gXCIgKyBoZWxwZnVsRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yLiBTdGF0dXM6JHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBsaXN0IHBlZXJzXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgbGlzdCBwZWVycyBmcm9tIHRoZSBzZXJ2ZXIuXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5IGV4dGVuZHMgKDAsICQ1MDQ1MTkyZmM2ZDM4N2JhJGV4cG9ydCQyM2EyYTY4MjgzYzI0ZDgwKSB7XG4gICAgc3RhdGljICNfID0gdGhpcy5JRF9QUkVGSVggPSBcImRjX1wiO1xuICAgIHN0YXRpYyAjXzIgPSB0aGlzLk1BWF9CVUZGRVJFRF9BTU9VTlQgPSA4Mzg4NjA4O1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5EYXRhO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25JZCB8fCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOS5JRF9QUkVGSVggKyAoMCwgJDBlNWZkMTU4NTc4NGMyNTIkZXhwb3J0JDRlNjFmNjcyOTM2YmVjNzcpKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgICAgIHRoaXMucmVsaWFibGUgPSAhIXRoaXMub3B0aW9ucy5yZWxpYWJsZTtcbiAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG5ldyAoMCwgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSkodGhpcyk7XG4gICAgICAgIHRoaXMuX25lZ290aWF0b3Iuc3RhcnRDb25uZWN0aW9uKHRoaXMub3B0aW9ucy5fcGF5bG9hZCB8fCB7XG4gICAgICAgICAgICBvcmlnaW5hdG9yOiB0cnVlLFxuICAgICAgICAgICAgcmVsaWFibGU6IHRoaXMucmVsaWFibGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIE5lZ290aWF0b3Igd2hlbiB0aGUgRGF0YUNoYW5uZWwgaXMgcmVhZHkuICovIF9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGMpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IGRjO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9ICgpPT57XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBkYyBjb25uZWN0aW9uIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIG9ubWVzc2FnZTpgLCBlLmRhdGEpO1xuICAgICAgICAvLyB0aGlzLl9oYW5kbGVEYXRhTWVzc2FnZShlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIGNsb3NlZCBmb3I6YCwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEV4cG9zZWQgZnVuY3Rpb25hbGl0eSBmb3IgdXNlcnMuXG5cdCAqLyAvKiogQWxsb3dzIHVzZXIgdG8gY2xvc2UgY29ubmVjdGlvbi4gKi8gY2xvc2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucz8uZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgX19wZWVyRGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsb3NlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmVnb3RpYXRvcikge1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvci5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fcmVtb3ZlQ29ubmVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybjtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICBzdXBlci5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxuICAgIC8qKiBBbGxvd3MgdXNlciB0byBzZW5kIGRhdGEuICovIHNlbmQoZGF0YSwgY2h1bmtlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDQ5YWU4MDBjMTE0ZGY0MWQpLk5vdE9wZW5ZZXQsIFwiQ29ubmVjdGlvbiBpcyBub3Qgb3Blbi4gWW91IHNob3VsZCBsaXN0ZW4gZm9yIHRoZSBgb3BlbmAgZXZlbnQgYmVmb3JlIHNlbmRpbmcgbWVzc2FnZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGRhdGEsIGNodW5rZWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuQW5zd2VyOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25lZ290aWF0b3IuaGFuZGxlU0RQKG1lc3NhZ2UudHlwZSwgcGF5bG9hZC5zZHApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkNhbmRpZGF0ZTpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZUNhbmRpZGF0ZShwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZTpcIiwgbWVzc2FnZS50eXBlLCBcImZyb20gcGVlcjpcIiwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5jbGFzcyAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4YiBleHRlbmRzICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkge1xuICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYykge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKT0+dGhpcy5faGFuZGxlRGF0YU1lc3NhZ2UoZSkpO1xuICAgIH1cbiAgICBfYnVmZmVyZWRTZW5kKG1zZykge1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyaW5nIHx8ICF0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5wdXNoKG1zZyk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbmQgc3VjY2VlZHMuXG4gICAgX3RyeVNlbmQobXNnKSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeUJ1ZmZlcigpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLnNlbmQobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKGBEQyM6JHt0aGlzLmNvbm5lY3Rpb25JZH0gRXJyb3Igd2hlbiBzZW5kaW5nOmAsIGUpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHNlbmQgdGhlIGZpcnN0IG1lc3NhZ2UgaW4gdGhlIGJ1ZmZlci5cbiAgICBfdHJ5QnVmZmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMub3BlbikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9idWZmZXJbMF07XG4gICAgICAgIGlmICh0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl90cnlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zPy5mbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICBfX3BlZXJEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xvc2VcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gMDtcbiAgICAgICAgc3VwZXIuY2xvc2UoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpLCB0aGlzLl9idWZmZXIgPSBbXSwgdGhpcy5fYnVmZmVyU2l6ZSA9IDAsIHRoaXMuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICAgIH1cbn1cblxuXG5cblxuY2xhc3MgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDggZXh0ZW5kcyAoMCwgJGEyMjliZWRiY2FhNmNhMjMkZXhwb3J0JGZmN2M5ZDRjMTFkOTRlOGIpIHtcbiAgICBjbG9zZShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmNsb3NlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jaHVua2VkRGF0YSA9IHt9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyksIHRoaXMuY2h1bmtlciA9IG5ldyAoMCwgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JGYxYzVmNGM5Y2I5NTM5MGIpKCksIHRoaXMuc2VyaWFsaXphdGlvbiA9ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkODlmNTA3Y2Y5ODZhOTQ3KS5CaW5hcnksIHRoaXMuX2NodW5rZWREYXRhID0ge307XG4gICAgfVxuICAgIC8vIEhhbmRsZXMgYSBEYXRhQ2hhbm5lbCBtZXNzYWdlLlxuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gKDAsICRnQ2NiWSR1bnBhY2spKGRhdGEpO1xuICAgICAgICAvLyBQZWVySlMgc3BlY2lmaWMgbWVzc2FnZVxuICAgICAgICBjb25zdCBwZWVyRGF0YSA9IGRlc2VyaWFsaXplZERhdGFbXCJfX3BlZXJEYXRhXCJdO1xuICAgICAgICBpZiAocGVlckRhdGEpIHtcbiAgICAgICAgICAgIGlmIChwZWVyRGF0YS50eXBlID09PSBcImNsb3NlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2h1bmtlZCBkYXRhIC0tIHBpZWNlIHRoaW5ncyBiYWNrIHRvZ2V0aGVyLlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2h1bmsoZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICB9XG4gICAgX2hhbmRsZUNodW5rKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaWQgPSBkYXRhLl9fcGVlckRhdGE7XG4gICAgICAgIGNvbnN0IGNodW5rSW5mbyA9IHRoaXMuX2NodW5rZWREYXRhW2lkXSB8fCB7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgICAgfTtcbiAgICAgICAgY2h1bmtJbmZvLmRhdGFbZGF0YS5uXSA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSk7XG4gICAgICAgIGNodW5rSW5mby5jb3VudCsrO1xuICAgICAgICB0aGlzLl9jaHVua2VkRGF0YVtpZF0gPSBjaHVua0luZm87XG4gICAgICAgIGlmIChjaHVua0luZm8udG90YWwgPT09IGNodW5rSW5mby5jb3VudCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIG1ha2luZyB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gYF9oYW5kbGVEYXRhTWVzc2FnZWAuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2h1bmtlZERhdGFbaWRdO1xuICAgICAgICAgICAgLy8gV2UndmUgcmVjZWl2ZWQgYWxsIHRoZSBjaHVua3MtLXRpbWUgdG8gY29uc3RydWN0IHRoZSBjb21wbGV0ZSBkYXRhLlxuICAgICAgICAgICAgLy8gY29uc3QgZGF0YSA9IG5ldyBCbG9iKGNodW5rSW5mby5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JDUyYzg5ZWJjZGM0ZjUzZjIpKGNodW5rSW5mby5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGFNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2VuZChkYXRhLCBjaHVua2VkKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSAoMCwgJGdDY2JZJHBhY2spKGRhdGEpO1xuICAgICAgICBpZiAoYmxvYiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB0aGlzLl9zZW5kX2Jsb2IoYmxvYik7XG4gICAgICAgIGlmICghY2h1bmtlZCAmJiBibG9iLmJ5dGVMZW5ndGggPiB0aGlzLmNodW5rZXIuY2h1bmtlZE1UVSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZENodW5rcyhibG9iKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWZmZXJlZFNlbmQoYmxvYik7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kX2Jsb2IoYmxvYlByb21pc2UpIHtcbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgICAgICBpZiAoYmxvYi5ieXRlTGVuZ3RoID4gdGhpcy5jaHVua2VyLmNodW5rZWRNVFUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDaHVua3MoYmxvYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGJsb2IpO1xuICAgIH1cbiAgICBfc2VuZENodW5rcyhibG9iKSB7XG4gICAgICAgIGNvbnN0IGJsb2JzID0gdGhpcy5jaHVua2VyLmNodW5rKGJsb2IpO1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBUcnkgdG8gc2VuZCAke2Jsb2JzLmxlbmd0aH0gY2h1bmtzLi4uYCk7XG4gICAgICAgIGZvciAoY29uc3QgYmxvYiBvZiBibG9icyl0aGlzLnNlbmQoYmxvYiwgdHJ1ZSk7XG4gICAgfVxufVxuXG5cblxuXG5jbGFzcyAkYmJhZWUzZjE1ZjcxNDY2MyRleHBvcnQkNmY4OGZlNDdkMzJjOWM5NCBleHRlbmRzICgwLCAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4Yikge1xuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBzdXBlci5lbWl0KFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgX3NlbmQoZGF0YSwgX2NodW5rZWQpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyksIHRoaXMuc2VyaWFsaXphdGlvbiA9ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkODlmNTA3Y2Y5ODZhOTQ3KS5Ob25lO1xuICAgIH1cbn1cblxuXG5cblxuXG5jbGFzcyAkODE3ZjkzMWUzZjkwOTZjZiRleHBvcnQkNDg4ODBhYzYzNWY0NzE4NiBleHRlbmRzICgwLCAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4Yikge1xuICAgIC8vIEhhbmRsZXMgYSBEYXRhQ2hhbm5lbCBtZXNzYWdlLlxuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5wYXJzZSh0aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEpKTtcbiAgICAgICAgLy8gUGVlckpTIHNwZWNpZmljIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgcGVlckRhdGEgPSBkZXNlcmlhbGl6ZWREYXRhW1wiX19wZWVyRGF0YVwiXTtcbiAgICAgICAgaWYgKHBlZXJEYXRhICYmIHBlZXJEYXRhLnR5cGUgPT09IFwiY2xvc2VcIikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgfVxuICAgIF9zZW5kKGRhdGEsIF9jaHVua2VkKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gdGhpcy5lbmNvZGVyLmVuY29kZSh0aGlzLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGlmIChlbmNvZGVkRGF0YS5ieXRlTGVuZ3RoID49ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuY2h1bmtlZE1UVSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkKS5NZXNzYWdlVG9CaWcsIFwiTWVzc2FnZSB0b28gYmlnIGZvciBKU09OIGNoYW5uZWxcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGVuY29kZWREYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpLCB0aGlzLnNlcmlhbGl6YXRpb24gPSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NykuSlNPTiwgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCksIHRoaXMuZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLCB0aGlzLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5LCB0aGlzLnBhcnNlID0gSlNPTi5wYXJzZTtcbiAgICB9XG59XG5cblxuXG5jbGFzcyAkNDE2MjYwYmNlMzM3ZGY5MCR2YXIkUGVlck9wdGlvbnMge1xufVxuY2xhc3MgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDggZXh0ZW5kcyAoMCwgJDIzNzc5ZDE4ODExNTdhMTgkZXhwb3J0JDZhNjc4ZTU4OWM4YTQ1NDIpIHtcbiAgICBzdGF0aWMgI18gPSB0aGlzLkRFRkFVTFRfS0VZID0gXCJwZWVyanNcIjtcbiAgICAvKipcblx0ICogVGhlIGJyb2tlcmluZyBJRCBvZiB0aGlzIHBlZXJcblx0ICpcblx0ICogSWYgbm8gSUQgd2FzIHNwZWNpZmllZCBpbiB7QGFwaWxpbmsgUGVlciB8IHRoZSBjb25zdHJ1Y3Rvcn0sXG5cdCAqIHRoaXMgd2lsbCBiZSBgdW5kZWZpbmVkYCB1bnRpbCB0aGUge0BhcGlsaW5rIFBlZXJFdmVudHMgfCBgb3BlbmB9IGV2ZW50IGlzIGVtaXR0ZWQuXG5cdCAqLyBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW47XG4gICAgfVxuICAgIC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovIGdldCBzb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBBIGhhc2ggb2YgYWxsIGNvbm5lY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHBlZXIsIGtleWVkIGJ5IHRoZSByZW1vdGUgcGVlcidzIElELlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBSZXR1cm4gdHlwZSB3aWxsIGNoYW5nZSBmcm9tIE9iamVjdCB0byBNYXA8c3RyaW5nLFtdPlxuXHQgKi8gZ2V0IGNvbm5lY3Rpb25zKCkge1xuICAgICAgICBjb25zdCBwbGFpbkNvbm5lY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5fY29ubmVjdGlvbnMpcGxhaW5Db25uZWN0aW9uc1trXSA9IHY7XG4gICAgICAgIHJldHVybiBwbGFpbkNvbm5lY3Rpb25zO1xuICAgIH1cbiAgICAvKipcblx0ICogdHJ1ZSBpZiB0aGlzIHBlZXIgYW5kIGFsbCBvZiBpdHMgY29ubmVjdGlvbnMgY2FuIG5vIGxvbmdlciBiZSB1c2VkLlxuXHQgKi8gZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgLyoqXG5cdCAqIGZhbHNlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBjb25uZWN0aW9uIHRvIHRoZSBQZWVyU2VydmVyLlxuXHQgKi8gZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaWQsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcigpLCB0aGlzLl9zZXJpYWxpemVycyA9IHtcbiAgICAgICAgICAgIHJhdzogKDAsICRiYmFlZTNmMTVmNzE0NjYzJGV4cG9ydCQ2Zjg4ZmU0N2QzMmM5Yzk0KSxcbiAgICAgICAgICAgIGpzb246ICgwLCAkODE3ZjkzMWUzZjkwOTZjZiRleHBvcnQkNDg4ODBhYzYzNWY0NzE4NiksXG4gICAgICAgICAgICBiaW5hcnk6ICgwLCAkOWZjZmRkYjNhZTE0OGY4OCRleHBvcnQkZjBhNWE2NGQ1YmIzNzEwOCksXG4gICAgICAgICAgICBcImJpbmFyeS11dGY4XCI6ICgwLCAkOWZjZmRkYjNhZTE0OGY4OCRleHBvcnQkZjBhNWE2NGQ1YmIzNzEwOCksXG4gICAgICAgICAgICBkZWZhdWx0OiAoMCwgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDgpXG4gICAgICAgIH0sIHRoaXMuX2lkID0gbnVsbCwgdGhpcy5fbGFzdFNlcnZlcklkID0gbnVsbCwgLy8gU3RhdGVzLlxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZSAvLyBDb25uZWN0aW9ucyBoYXZlIGJlZW4ga2lsbGVkXG4gICAgICAgICwgdGhpcy5fZGlzY29ubmVjdGVkID0gZmFsc2UgLy8gQ29ubmVjdGlvbiB0byBQZWVyU2VydmVyIGtpbGxlZCBidXQgUDJQIGNvbm5lY3Rpb25zIHN0aWxsIGFjdGl2ZVxuICAgICAgICAsIHRoaXMuX29wZW4gPSBmYWxzZSAvLyBTb2NrZXRzIGFuZCBzdWNoIGFyZSBub3QgeWV0IG9wZW4uXG4gICAgICAgICwgdGhpcy5fY29ubmVjdGlvbnMgPSBuZXcgTWFwKCkgLy8gQWxsIGNvbm5lY3Rpb25zIGZvciB0aGlzIHBlZXIuXG4gICAgICAgICwgdGhpcy5fbG9zdE1lc3NhZ2VzID0gbmV3IE1hcCgpIC8vIHNyYyA9PiBbbGlzdCBvZiBtZXNzYWdlc11cbiAgICAgICAgO1xuICAgICAgICBsZXQgdXNlcklkO1xuICAgICAgICAvLyBEZWFsIHdpdGggb3ZlcmxvYWRpbmdcbiAgICAgICAgaWYgKGlkICYmIGlkLmNvbnN0cnVjdG9yID09IE9iamVjdCkgb3B0aW9ucyA9IGlkO1xuICAgICAgICBlbHNlIGlmIChpZCkgdXNlcklkID0gaWQudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gQ29uZmlndXJpemUgb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZGVidWc6IDAsXG4gICAgICAgICAgICBob3N0OiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLkNMT1VEX0hPU1QsXG4gICAgICAgICAgICBwb3J0OiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLkNMT1VEX1BPUlQsXG4gICAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgICAgIGtleTogJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDguREVGQVVMVF9LRVksXG4gICAgICAgICAgICB0b2tlbjogKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5yYW5kb21Ub2tlbigpLFxuICAgICAgICAgICAgY29uZmlnOiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICAgICAgICBzZXJpYWxpemVyczoge30sXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX3NlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnNlcmlhbGl6ZXJzXG4gICAgICAgIH07XG4gICAgICAgIC8vIERldGVjdCByZWxhdGl2ZSBVUkwgaG9zdC5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaG9zdCA9PT0gXCIvXCIpIHRoaXMuX29wdGlvbnMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgLy8gU2V0IHBhdGggY29ycmVjdGx5LlxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoWzBdICE9PSBcIi9cIikgdGhpcy5fb3B0aW9ucy5wYXRoID0gXCIvXCIgKyB0aGlzLl9vcHRpb25zLnBhdGg7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoW3RoaXMuX29wdGlvbnMucGF0aC5sZW5ndGggLSAxXSAhPT0gXCIvXCIpIHRoaXMuX29wdGlvbnMucGF0aCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgd2hldGhlciB3ZSB1c2UgU1NMIHRvIHNhbWUgYXMgY3VycmVudCBob3N0XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNlY3VyZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX29wdGlvbnMuaG9zdCAhPT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSB0aGlzLl9vcHRpb25zLnNlY3VyZSA9ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuaXNTZWN1cmUoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5ob3N0ID09ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuQ0xPVURfSE9TVCkgdGhpcy5fb3B0aW9ucy5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAvLyBTZXQgYSBjdXN0b20gbG9nIGZ1bmN0aW9uIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubG9nRnVuY3Rpb24pICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5zZXRMb2dGdW5jdGlvbih0aGlzLl9vcHRpb25zLmxvZ0Z1bmN0aW9uKTtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZ0xldmVsID0gdGhpcy5fb3B0aW9ucy5kZWJ1ZyB8fCAwO1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgKDAsICRhYmYyNjY2NDE5MjdjZDg5JGV4cG9ydCQyYzRlODI1ZGM5MTIwZjg3KShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gdGhpcy5fY3JlYXRlU2VydmVyQ29ubmVjdGlvbigpO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2tzXG4gICAgICAgIC8vIEVuc3VyZSBXZWJSVEMgc3VwcG9ydGVkXG4gICAgICAgIGlmICghKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5zdXBwb3J0cy5hdWRpb1ZpZGVvICYmICEoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLnN1cHBvcnRzLmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkJyb3dzZXJJbmNvbXBhdGlibGUsIFwiVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQ1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgYWxwaGFudW1lcmljIGlkXG4gICAgICAgIGlmICghIXVzZXJJZCAmJiAhKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS52YWxpZGF0ZUlkKHVzZXJJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkludmFsaWRJRCwgYElEIFwiJHt1c2VySWR9XCIgaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VySWQpIHRoaXMuX2luaXRpYWxpemUodXNlcklkKTtcbiAgICAgICAgZWxzZSB0aGlzLl9hcGkucmV0cmlldmVJZCgpLnRoZW4oKGlkKT0+dGhpcy5faW5pdGlhbGl6ZShpZCkpLmNhdGNoKChlcnJvcik9PnRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU2VydmVyRXJyb3IsIGVycm9yKSk7XG4gICAgfVxuICAgIF9jcmVhdGVTZXJ2ZXJDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgKDAsICQ4ZjViZmE2MDgzNmQyNjFkJGV4cG9ydCQ0Nzk4OTE3ZGJmMTQ5Yjc5KSh0aGlzLl9vcHRpb25zLnNlY3VyZSwgdGhpcy5fb3B0aW9ucy5ob3N0LCB0aGlzLl9vcHRpb25zLnBvcnQsIHRoaXMuX29wdGlvbnMucGF0aCwgdGhpcy5fb3B0aW9ucy5rZXksIHRoaXMuX29wdGlvbnMucGluZ0ludGVydmFsKTtcbiAgICAgICAgc29ja2V0Lm9uKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuTWVzc2FnZSwgKGRhdGEpPT57XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9uKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuRXJyb3IsIChlcnJvcik9PntcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU29ja2V0RXJyb3IsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLkRpc2Nvbm5lY3RlZCwgKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5OZXR3b3JrLCBcIkxvc3QgY29ubmVjdGlvbiB0byBzZXJ2ZXIuXCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5DbG9zZSwgKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5Tb2NrZXRDbG9zZWQsIFwiVW5kZXJseWluZyBzb2NrZXQgaXMgYWxyZWFkeSBjbG9zZWQuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemUgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci4gKi8gX2luaXRpYWxpemUoaWQpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5zb2NrZXQuc3RhcnQoaWQsIHRoaXMuX29wdGlvbnMudG9rZW4pO1xuICAgIH1cbiAgICAvKiogSGFuZGxlcyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuICovIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgY29uc3QgcGVlcklkID0gbWVzc2FnZS5zcmM7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5PcGVuOlxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTZXJ2ZXJJZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiLCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5FcnJvcjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlNlcnZlckVycm9yLCBwYXlsb2FkLm1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuSWRUYWtlbjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlVuYXZhaWxhYmxlSUQsIGBJRCBcIiR7dGhpcy5pZH1cIiBpcyB0YWtlbmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkludmFsaWRLZXk6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5JbnZhbGlkS2V5LCBgQVBJIEtFWSBcIiR7dGhpcy5fb3B0aW9ucy5rZXl9XCIgaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkxlYXZlOlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFJlY2VpdmVkIGxlYXZlIG1lc3NhZ2UgZnJvbSAke3BlZXJJZH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVySWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShwZWVySWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkV4cGlyZTpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlBlZXJVbmF2YWlsYWJsZSwgYENvdWxkIG5vdCBjb25uZWN0IHRvIHBlZXIgJHtwZWVySWR9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuT2ZmZXI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIHRoaXMgdG8gQ0FMTC9DT05ORUNULCBidXQgdGhpcyBpcyB0aGUgbGVhc3QgYnJlYWtpbmcgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oYE9mZmVyIHJlY2VpdmVkIGZvciBleGlzdGluZyBDb25uZWN0aW9uIElEOiR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZWRpYUNvbm5lY3Rpb24gPSBuZXcgKDAsICQ1YzFkMDhjN2M1N2RhOWEzJGV4cG9ydCQ0YTg0ZTk1YTIzMjRhYzI5KShwZWVySWQsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbWVkaWFDb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2FsbFwiLCBtZWRpYUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQudHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IG5ldyB0aGlzLl9zZXJpYWxpemVyc1twYXlsb2FkLnNlcmlhbGl6YXRpb25dKHBlZXJJZCwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYXlsb2FkLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb246IHBheWxvYWQuc2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxpYWJsZTogcGF5bG9hZC5yZWxpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gZGF0YUNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIGRhdGFDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBSZWNlaXZlZCBtYWxmb3JtZWQgY29ubmVjdGlvbiB0eXBlOiR7cGF5bG9hZC50eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5fZ2V0TWVzc2FnZXMoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKWNvbm5lY3Rpb24uaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oYFlvdSByZWNlaXZlZCBhIG1hbGZvcm1lZCBtZXNzYWdlIGZyb20gJHtwZWVySWR9IG9mIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IHBheWxvYWQuY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbikgLy8gUGFzcyBpdCBvbi5cbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25uZWN0aW9uSWQpIC8vIFN0b3JlIGZvciBwb3NzaWJsZSBsYXRlciB1c2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVNZXNzYWdlKGNvbm5lY3Rpb25JZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oXCJZb3UgcmVjZWl2ZWQgYW4gdW5yZWNvZ25pemVkIG1lc3NhZ2U6XCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFN0b3JlcyBtZXNzYWdlcyB3aXRob3V0IGEgc2V0IHVwIGNvbm5lY3Rpb24sIHRvIGJlIGNsYWltZWQgbGF0ZXIuICovIF9zdG9yZU1lc3NhZ2UoY29ubmVjdGlvbklkLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9zdE1lc3NhZ2VzLmhhcyhjb25uZWN0aW9uSWQpKSB0aGlzLl9sb3N0TWVzc2FnZXMuc2V0KGNvbm5lY3Rpb25JZCwgW10pO1xuICAgICAgICB0aGlzLl9sb3N0TWVzc2FnZXMuZ2V0KGNvbm5lY3Rpb25JZCkucHVzaChtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIFJldHJpZXZlIG1lc3NhZ2VzIGZyb20gbG9zdCBtZXNzYWdlIHN0b3JlXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi8gLy9UT0RPIENoYW5nZSBpdCB0byBwcml2YXRlXG4gICAgX2dldE1lc3NhZ2VzKGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuX2xvc3RNZXNzYWdlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3N0TWVzc2FnZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcblx0ICogQ29ubmVjdHMgdG8gdGhlIHJlbW90ZSBwZWVyIHNwZWNpZmllZCBieSBpZCBhbmQgcmV0dXJucyBhIGRhdGEgY29ubmVjdGlvbi5cblx0ICogQHBhcmFtIHBlZXIgVGhlIGJyb2tlcmluZyBJRCBvZiB0aGUgcmVtb3RlIHBlZXIgKHRoZWlyIHtAYXBpbGluayBQZWVyLmlkfSkuXG5cdCAqIEBwYXJhbSBvcHRpb25zIGZvciBzcGVjaWZ5aW5nIGRldGFpbHMgYWJvdXQgUGVlciBDb25uZWN0aW9uXG5cdCAqLyBjb25uZWN0KHBlZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oXCJZb3UgY2Fubm90IGNvbm5lY3QgdG8gYSBuZXcgUGVlciBiZWNhdXNlIHlvdSBjYWxsZWQgLmRpc2Nvbm5lY3QoKSBvbiB0aGlzIFBlZXIgYW5kIGVuZGVkIHlvdXIgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIuIFlvdSBjYW4gY3JlYXRlIGEgbmV3IFBlZXIgdG8gcmVjb25uZWN0LCBvciBjYWxsIHJlY29ubmVjdCBvbiB0aGlzIHBlZXIgaWYgeW91IGJlbGlldmUgaXRzIElEIHRvIHN0aWxsIGJlIGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkRpc2Nvbm5lY3RlZCwgXCJDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IG5ldyB0aGlzLl9zZXJpYWxpemVyc1tvcHRpb25zLnNlcmlhbGl6YXRpb25dKHBlZXIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGRhdGFDb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRhdGFDb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKipcblx0ICogQ2FsbHMgdGhlIHJlbW90ZSBwZWVyIHNwZWNpZmllZCBieSBpZCBhbmQgcmV0dXJucyBhIG1lZGlhIGNvbm5lY3Rpb24uXG5cdCAqIEBwYXJhbSBwZWVyIFRoZSBicm9rZXJpbmcgSUQgb2YgdGhlIHJlbW90ZSBwZWVyICh0aGVpciBwZWVyLmlkKS5cblx0ICogQHBhcmFtIHN0cmVhbSBUaGUgY2FsbGVyJ3MgbWVkaWEgc3RyZWFtXG5cdCAqIEBwYXJhbSBvcHRpb25zIE1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvbiwgcGFzc2VkIGluIGJ5IHdob2V2ZXIgaW5pdGlhdGVkIHRoZSBjb25uZWN0aW9uLlxuXHQgKi8gY2FsbChwZWVyLCBzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkIC5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyLiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBQZWVyIHRvIHJlY29ubmVjdC5cIik7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkRpc2Nvbm5lY3RlZCwgXCJDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiVG8gY2FsbCBhIHBlZXIsIHlvdSBtdXN0IHByb3ZpZGUgYSBzdHJlYW0gZnJvbSB5b3VyIGJyb3dzZXIncyBgZ2V0VXNlck1lZGlhYC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFDb25uZWN0aW9uID0gbmV3ICgwLCAkNWMxZDA4YzdjNTdkYTlhMyRleHBvcnQkNGE4NGU5NWEyMzI0YWMyOSkocGVlciwgdGhpcywge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIF9zdHJlYW06IHN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBtZWRpYUNvbm5lY3Rpb24pO1xuICAgICAgICByZXR1cm4gbWVkaWFDb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKiogQWRkIGEgZGF0YS9tZWRpYSBjb25uZWN0aW9uIHRvIHRoaXMgcGVlci4gKi8gX2FkZENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGFkZCBjb25uZWN0aW9uICR7Y29ubmVjdGlvbi50eXBlfToke2Nvbm5lY3Rpb24uY29ubmVjdGlvbklkfSB0byBwZWVySWQ6JHtwZWVySWR9YCk7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnMuaGFzKHBlZXJJZCkpIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChwZWVySWQsIFtdKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMuZ2V0KHBlZXJJZCkucHVzaChjb25uZWN0aW9uKTtcbiAgICB9XG4gICAgLy9UT0RPIHNob3VsZCBiZSBwcml2YXRlXG4gICAgX3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgICBpZiAoY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIGNvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBsb3N0IG1lc3NhZ2VzXG4gICAgICAgIHRoaXMuX2xvc3RNZXNzYWdlcy5kZWxldGUoY29ubmVjdGlvbi5jb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgICAvKiogUmV0cmlldmUgYSBkYXRhL21lZGlhIGNvbm5lY3Rpb24gZm9yIHRoaXMgcGVlci4gKi8gZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChwZWVySWQpO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25zKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKXtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25JZCA9PT0gY29ubmVjdGlvbklkKSByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2RlbGF5ZWRBYm9ydCh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yIG1lc3NhZ2UgYW5kIGRlc3Ryb3lzIHRoZSBQZWVyLlxuXHQgKiBUaGUgUGVlciBpcyBub3QgZGVzdHJveWVkIGlmIGl0J3MgaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGUsIGluIHdoaWNoIGNhc2Vcblx0ICogaXQgcmV0YWlucyBpdHMgZGlzY29ubmVjdGVkIHN0YXRlIGFuZCBpdHMgZXhpc3RpbmcgY29ubmVjdGlvbnMuXG5cdCAqLyBfYWJvcnQodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoXCJBYm9ydGluZyFcIik7XG4gICAgICAgIHRoaXMuZW1pdEVycm9yKHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICBpZiAoIXRoaXMuX2xhc3RTZXJ2ZXJJZCkgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGVsc2UgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgUGVlcjogY2xvc2VzIGFsbCBhY3RpdmUgY29ubmVjdGlvbnMgYXMgd2VsbCBhcyB0aGUgY29ubmVjdGlvblxuXHQgKiB0byB0aGUgc2VydmVyLlxuXHQgKlxuXHQgKiA6OjpjYXV0aW9uXG5cdCAqIFRoaXMgY2Fubm90IGJlIHVuZG9uZTsgdGhlIHJlc3BlY3RpdmUgcGVlciBvYmplY3Qgd2lsbCBubyBsb25nZXIgYmUgYWJsZVxuXHQgKiB0byBjcmVhdGUgb3IgcmVjZWl2ZSBhbnkgY29ubmVjdGlvbnMsIGl0cyBJRCB3aWxsIGJlIGZvcmZlaXRlZCBvbiB0aGUgc2VydmVyLFxuXHQgKiBhbmQgYWxsIG9mIGl0cyBkYXRhIGFuZCBtZWRpYSBjb25uZWN0aW9ucyB3aWxsIGJlIGNsb3NlZC5cblx0ICogOjo6XG5cdCAqLyBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgRGVzdHJveSBwZWVyIHdpdGggSUQ6JHt0aGlzLmlkfWApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICB9XG4gICAgLyoqIERpc2Nvbm5lY3RzIGV2ZXJ5IGNvbm5lY3Rpb24gb24gdGhpcyBwZWVyLiAqLyBfY2xlYW51cCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwZWVySWQgb2YgdGhpcy5fY29ubmVjdGlvbnMua2V5cygpKXtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXBQZWVyKHBlZXJJZCk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUocGVlcklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgdG8gdGhpcyBwZWVyLiAqLyBfY2xlYW51cFBlZXIocGVlcklkKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KHBlZXJJZCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbnMpIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKWNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIERpc2Nvbm5lY3RzIHRoZSBQZWVyJ3MgY29ubmVjdGlvbiB0byB0aGUgUGVlclNlcnZlci4gRG9lcyBub3QgY2xvc2UgYW55XG5cdCAqICBhY3RpdmUgY29ubmVjdGlvbnMuXG5cdCAqIFdhcm5pbmc6IFRoZSBwZWVyIGNhbiBubyBsb25nZXIgY3JlYXRlIG9yIGFjY2VwdCBjb25uZWN0aW9ucyBhZnRlciBiZWluZ1xuXHQgKiAgZGlzY29ubmVjdGVkLiBJdCBhbHNvIGNhbm5vdCByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci5cblx0ICovIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50SWQgPSB0aGlzLmlkO1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEaXNjb25uZWN0IHBlZXIgd2l0aCBJRDoke2N1cnJlbnRJZH1gKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9sYXN0U2VydmVySWQgPSBjdXJyZW50SWQ7XG4gICAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIsIGN1cnJlbnRJZCk7XG4gICAgfVxuICAgIC8qKiBBdHRlbXB0cyB0byByZWNvbm5lY3Qgd2l0aCB0aGUgc2FtZSBJRC5cblx0ICpcblx0ICogT25seSB7QGFwaWxpbmsgUGVlci5kaXNjb25uZWN0IHwgZGlzY29ubmVjdGVkIHBlZXJzfSBjYW4gYmUgcmVjb25uZWN0ZWQuXG5cdCAqIERlc3Ryb3llZCBwZWVycyBjYW5ub3QgYmUgcmVjb25uZWN0ZWQuXG5cdCAqIElmIHRoZSBjb25uZWN0aW9uIGZhaWxzIChhcyBhbiBleGFtcGxlLCBpZiB0aGUgcGVlcidzIG9sZCBJRCBpcyBub3cgdGFrZW4pLFxuXHQgKiB0aGUgcGVlcidzIGV4aXN0aW5nIGNvbm5lY3Rpb25zIHdpbGwgbm90IGNsb3NlLCBidXQgYW55IGFzc29jaWF0ZWQgZXJyb3JzIGV2ZW50cyB3aWxsIGZpcmUuXG5cdCAqLyByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYEF0dGVtcHRpbmcgcmVjb25uZWN0aW9uIHRvIHNlcnZlciB3aXRoIElEICR7dGhpcy5fbGFzdFNlcnZlcklkfWApO1xuICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKHRoaXMuX2xhc3RTZXJ2ZXJJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcGVlciBjYW5ub3QgcmVjb25uZWN0IHRvIHRoZSBzZXJ2ZXIuIEl0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKTtcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZGlzY29ubmVjdGVkICYmICF0aGlzLm9wZW4pIC8vIERvIG5vdGhpbmcuIFdlJ3JlIHN0aWxsIGNvbm5lY3RpbmcgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIkluIGEgaHVycnk/IFdlJ3JlIHN0aWxsIHRyeWluZyB0byBtYWtlIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24hXCIpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgUGVlciAke3RoaXMuaWR9IGNhbm5vdCByZWNvbm5lY3QgYmVjYXVzZSBpdCBpcyBub3QgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlciFgKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEdldCBhIGxpc3Qgb2YgYXZhaWxhYmxlIHBlZXIgSURzLiBJZiB5b3UncmUgcnVubmluZyB5b3VyIG93biBzZXJ2ZXIsIHlvdSdsbFxuXHQgKiB3YW50IHRvIHNldCBhbGxvd19kaXNjb3Zlcnk6IHRydWUgaW4gdGhlIFBlZXJTZXJ2ZXIgb3B0aW9ucy4gSWYgeW91J3JlIHVzaW5nXG5cdCAqIHRoZSBjbG91ZCBzZXJ2ZXIsIGVtYWlsIHRlYW1AcGVlcmpzLmNvbSB0byBnZXQgdGhlIGZ1bmN0aW9uYWxpdHkgZW5hYmxlZCBmb3Jcblx0ICogeW91ciBrZXkuXG5cdCAqLyBsaXN0QWxsUGVlcnMoY2IgPSAoXyk9Pnt9KSB7XG4gICAgICAgIHRoaXMuX2FwaS5saXN0QWxsUGVlcnMoKS50aGVuKChwZWVycyk9PmNiKHBlZXJzKSkuY2F0Y2goKGVycm9yKT0+dGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5TZXJ2ZXJFcnJvciwgZXJyb3IpKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG5jbGFzcyAkMjBkYmU2ODE0OWQ3YWFkOSRleHBvcnQkNzJhYTQ0NjEyZTIyMDBjZCBleHRlbmRzICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkge1xuICAgIGNvbnN0cnVjdG9yKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihwZWVySWQsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgcmVsaWFibGU6IHRydWVcbiAgICAgICAgfSksIHRoaXMuX0NIVU5LX1NJWkUgPSAzMjc2OCwgdGhpcy5fc3BsaXRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIGZvcihsZXQgc3BsaXQgPSAwOyBzcGxpdCA8IGNodW5rLmxlbmd0aDsgc3BsaXQgKz0gdGhpcy5fQ0hVTktfU0laRSljb250cm9sbGVyLmVucXVldWUoY2h1bmsuc3ViYXJyYXkoc3BsaXQsIHNwbGl0ICsgdGhpcy5fQ0hVTktfU0laRSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5fcmF3U2VuZFN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5FdmVudCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+dGhpcy5kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwiYnVmZmVyZWRhbW91bnRsb3dcIiwgcmVzb2x2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuIHNlbmQgdGhlIGNodW5rIG5vdywgc2VuZCBpdFxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCwgd2Ugd2FpdCB1bnRpbCBhdCBsZWFzdCBoYWxmIG9mIHRoZSBzZW5kaW5nIGJ1ZmZlciBpcyBmcmVlIGFnYWluXG4gICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuZGF0YUNoYW5uZWwuYnVmZmVyZWRBbW91bnQgPD0gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UIC0gY2h1bmsuYnl0ZUxlbmd0aCB8fCBvcGVuRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgY2FuIGdvIHdyb25nIGhlcmU/XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5zZW5kKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihgREMjOiR7dGhpcy5jb25uZWN0aW9uSWR9IEVycm9yIHdoZW4gc2VuZGluZzpgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRoaXMud3JpdGVyID0gdGhpcy5fc3BsaXRTdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCksIHRoaXMuX3Jhd1JlYWRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQ6IChjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NwbGl0U3RyZWFtLnJlYWRhYmxlLnBpcGVUbyh0aGlzLl9yYXdTZW5kU3RyZWFtKTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYykge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UIC8gMjtcbiAgICB9XG59XG5cblxuY2xhc3MgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQgZXh0ZW5kcyAoMCwgJDIwZGJlNjgxNDlkN2FhZDkkZXhwb3J0JDcyYWE0NDYxMmUyMjAwY2QpIHtcbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyksIHRoaXMuc2VyaWFsaXphdGlvbiA9IFwiTXNnUGFja1wiLCB0aGlzLl9lbmNvZGVyID0gbmV3ICgwLCAkZ0NjYlkkRW5jb2RlcikoKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG1zZyBvZiAoMCwgJGdDY2JZJGRlY29kZU11bHRpU3RyZWFtKSh0aGlzLl9yYXdSZWFkU3RyZWFtKSl7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChtc2cuX19wZWVyRGF0YT8udHlwZSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9zZW5kKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVyLndyaXRlKHRoaXMuX2VuY29kZXIuZW5jb2RlKGRhdGEpKTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDFlMGFmZjE2YmUyYzMyOGUkZXhwb3J0JGQ3MmM3YmY4ZWVmNTA4NTMgZXh0ZW5kcyAoMCwgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDgpIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyksIHRoaXMuX3NlcmlhbGl6ZXJzID0ge1xuICAgICAgICAgICAgTXNnUGFjazogJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQsXG4gICAgICAgICAgICBkZWZhdWx0OiAoMCwgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQpXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cblxuXG5cblxuXG52YXIgJGRkMDE4N2Q3ZjI4ZTM4NmYkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSA9ICgwLCAkNDE2MjYwYmNlMzM3ZGY5MCRleHBvcnQkZWNkMWZjMTM2YzQyMjQ0OCk7XG5cblxuZXhwb3J0IHskZGQwMTg3ZDdmMjhlMzg2ZiRleHBvcnQkMmUyYmNkODczOWFlMDM5IGFzIGRlZmF1bHQsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiIGFzIHV0aWwsICRhMjI5YmVkYmNhYTZjYTIzJGV4cG9ydCRmZjdjOWQ0YzExZDk0ZThiIGFzIEJ1ZmZlcmVkQ29ubmVjdGlvbiwgJDIwZGJlNjgxNDlkN2FhZDkkZXhwb3J0JDcyYWE0NDYxMmUyMjAwY2QgYXMgU3RyZWFtQ29ubmVjdGlvbiwgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQgYXMgTXNnUGFjaywgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDggYXMgUGVlciwgJDFlMGFmZjE2YmUyYzMyOGUkZXhwb3J0JGQ3MmM3YmY4ZWVmNTA4NTMgYXMgTXNnUGFja1BlZXIsICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ5ODg3MTg4MmY0OTJkZTgyIGFzIFBlZXJFcnJvciwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMgYXMgQ29ubmVjdGlvblR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmIGFzIFBlZXJFcnJvclR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2IGFzIEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZCBhcyBEYXRhQ29ubmVjdGlvbkVycm9yVHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NyBhcyBTZXJpYWxpemF0aW9uVHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMgYXMgU29ja2V0RXZlbnRUeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCBhcyBTZXJ2ZXJNZXNzYWdlVHlwZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs/dist/bundler.mjs\n");

/***/ })

};
;